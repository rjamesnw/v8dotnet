<?xml version="1.0"?>
<doc>
    <assembly>
        <name>V8.Net</name>
    </assembly>
    <members>
        <member name="T:V8.Net.Context">
            <summary>
                Represents a V8 context in which JavaScript is executed. You can call
                <see cref="M:V8.Net.V8Engine.CreateContext(V8.Net.ObjectTemplate)"/> to create new executing contexts with a new default/custom
                global object.
            </summary>
            <seealso cref="T:System.IDisposable"/>
        </member>
        <member name="T:V8.Net.DynamicHandle">
            <summary>
            This is a class used internally to create a meta object for dynamic access to object properties for object based handles.
            </summary>
        </member>
        <member name="M:V8.Net.V8NetProxy.DeleteObjectTemplateProxy64(V8.Net.NativeObjectTemplateProxy*)">
            <summary> Returns true if successful. False is returned if the engine is in the middle of running a script, or performing another request. </summary>
        </member>
        <member name="M:V8.Net.V8NetProxy.DeleteFunctionTemplateProxy64(V8.Net.NativeFunctionTemplateProxy*)">
            <summary> Returns true if successful. False is returned if the engine is in the middle of running a script, or performing another request. </summary>
        </member>
        <member name="F:V8.Net.Loader.AlternateRootSubPath">
            <summary>
            The sub-folder that is the root for the dependent libraries (x86 and x64).  This is set to "V8.NET" by default.
            <para>This setting allows copying the V8.NET libraries to a project, and having the assemblies "Copy if never"
            automatically. Typically the path is relative, but an absolute root path can also be given.</para>
            </summary>
        </member>
        <member name="M:V8.Net.Loader.ResolveDependencies">
            <summary>
                This is the main method to call to resolve all dependencies. This MUST be the first method called, which is
                automatically called by the V8Engine's static constructor. You can also call this directly in a "main" or "startup"
                file before touching any V8.Net type.
            </summary>
        </member>
        <member name="P:V8.Net.Loader.ValidPaths">
            <summary> Compiles all the valid search paths, in proper order, based on the current settings. </summary>
            <value> The valid paths. </value>
        </member>
        <member name="M:V8.Net.Loader._GetSubPaths(System.String,System.String,System.Boolean)">
            <summary> Returns a list of sub-paths to try for the given root path. </summary>
            <param name="rootPath"> Full pathname of the root file. </param>
            <param name="subPath"> (Optional) Full pathname of the sub file. </param>
            <param name="includeRoot"> (Optional) True to include the root path. </param>
            <returns> An enumerator that allows foreach to be used to process the valid paths in this collection. </returns>
        </member>
        <member name="T:V8.Net.ScriptMemberSecurity">
            <summary>
            Flags which Determine the script accessibility.
            </summary>
        </member>
        <member name="F:V8.Net.ScriptMemberSecurity.NoAcccess">
            <summary>
            Used internally to prevent access to a script member on instance types.
            <para>Warning: This has no affect on STATIC bound properties.  There is no such related security option in V8 
            when setting properties. Bound instance objects use an ObjectBinder that wraps an object created from an ObjectTemplate.
            This allows advanced access control.  Class/struct declarations use V8 FunctionTemplates instead, which do not
            provide any callback interception for properties.  If set on the native side (not using ObjectTemplates), then this
            will map to both 'Locked|Hidden' flags being set.</para>
            </summary>
        </member>
        <member name="F:V8.Net.ScriptMemberSecurity.ReadWrite">
            <summary>
            If this flag is set, then the property can be read and/or written to.
            <para>Note: This is the default behaviour, and doesn't need to be explicitly set.</para>
            </summary>
        </member>
        <member name="F:V8.Net.ScriptMemberSecurity.ReadOnly">
            <summary>
            If this flag is set, then the Property can only be read (takes precedence over 'ReadWrite').
            </summary>
        </member>
        <member name="F:V8.Net.ScriptMemberSecurity.Hidden">
            <summary>
            If this flag is set, then the property is hidden from enumeration (but not from access).
            </summary>
        </member>
        <member name="F:V8.Net.ScriptMemberSecurity.Permanent">
            <summary>
            If this flag is set, then the property cannot be deleted (from within the script).
            </summary>
        </member>
        <member name="F:V8.Net.ScriptMemberSecurity.Locked">
            <summary>
            If this flag is set, then the property cannot be deleted OR overwritten (from within the script; this is equal to setting both 'Permanent|ReadOnly' flags).
            </summary>
        </member>
        <member name="T:V8.Net.ScriptMember">
            <summary>
            By default, public class members are NOT accessible by script for security reasons (unless the 'ScriptObject' attribute is used).
            This attribute allows controlling how class members are exposed to the scripting environment.
            </summary>
        </member>
        <member name="M:V8.Net.ScriptMember.#ctor(System.String,V8.Net.ScriptMemberSecurity)">
            <summary>
            Allows controlling how this class member is exposed to the scripting environment.
            </summary>
            <param name="inScriptName">The type name to expose to the scripting environment for this member (default is null/empty, which means use the member name as is).</param>
            <param name="security">The script access security for this member.</param>
        </member>
        <member name="M:V8.Net.ScriptMember.#ctor(V8.Net.ScriptMemberSecurity)">
            <summary>
            Allows controlling how this class member is exposed to the scripting environment.
            </summary>
            <param name="security">The script access security for this member.</param>
        </member>
        <member name="T:V8.Net.ScriptObject">
            <summary>
            This attribute allows specifying the default member access for all public members of a class at once.
            If just the attribute name is used, the security defaults to 'None' (the V8 default) for each member where possible.
            </summary>
        </member>
        <member name="M:V8.Net.ScriptObject.#ctor(System.String,V8.Net.ScriptMemberSecurity)">
            <summary>
            Allows specifying the default member access for all public members of this class at once.
            </summary>
            <param name="typeName">The function name to use when exposing a class to the scripting environment (default is null/empty, which means use the class name as is).</param>
            <param name="security">The global default access for all public class members (default is read/write).</param>
        </member>
        <member name="M:V8.Net.ScriptObject.#ctor(V8.Net.ScriptMemberSecurity)">
            <summary>
            Allows specifying the default member access for all public members of a class at once.
            </summary>
            <param name="security">The global default access for all public class members.</param>
        </member>
        <member name="T:V8.Net.V8PropertyAttributes">
            <summary>
            Flags that describe JavaScript properties.  They must be 'OR'd together as needed.
            </summary>
        </member>
        <member name="F:V8.Net.V8PropertyAttributes.Undefined">
            <summary>
            No valid attribute exists (unlike 'None', which *explicitly* defines that no attributes are set).
            The native PROXY (not V8) will interpret this to mean "let V8 continue on to the default behavior".
            <para>Warning: This cannot be bitwise "OR"ed with the other enum values. Also, this is not supported on the native V8 side.</para>
            </summary>
        </member>
        <member name="F:V8.Net.V8PropertyAttributes.None">
            <summary>
            No attribute is set - keeps the default behaviour of all attributes NOT set.
            <para>Note: When checking object properties for attributes, V8 will return 'None' if a property doesn't exist. 'Undefined' is for V8.Net usage only
            (used with interceptor callbacks/hooks).</para>
            </summary>
        </member>
        <member name="F:V8.Net.V8PropertyAttributes.ReadOnly">
            <summary>
            The property can only be read from.
            </summary>
        </member>
        <member name="F:V8.Net.V8PropertyAttributes.DontEnum">
            <summary>
            The property is visible, but should not be returned during enumeration.
            </summary>
        </member>
        <member name="F:V8.Net.V8PropertyAttributes.DontDelete">
            <summary>
            The property cannot be deleted.
            </summary>
        </member>
        <member name="F:V8.Net.V8PropertyAttributes.Locked">
            <summary>
            This is equal to "ReadOnly | DontDelete", and is a V8.NET specific attribute name.
            It's here because locking down properties is a common operation when adding some fixed global types and objects.
            </summary>
        </member>
        <member name="T:V8.Net.V8AccessControl">
            <summary>
            V8 Access control specification flags.  If some accessors should be accessible across native V8 contexts, then these accessors need an explicit access
            control parameter set which specifies the kind of cross-context access that should be allowed.
            </summary>
        </member>
        <member name="F:V8.Net.V8AccessControl.Undefined">
            <summary>
            No valid access value exists (unlike 'Default', which *explicitly* defines to use the default behavior).
            <para>Note: This value is used internally by V8.NET and is not part of the native V8 system.</para>
            </summary>
        </member>
        <member name="F:V8.Net.V8AccessControl.Default">
            <summary>
            Keeps the default behaviour of "no flags set".
            </summary>
        </member>
        <member name="F:V8.Net.V8AccessControl.AllCanRead">
            <summary>
            The property can be read from all contexts.
            </summary>
        </member>
        <member name="F:V8.Net.V8AccessControl.AllCanWrite">
            <summary>
            The property can be written to by all contexts.
            </summary>
        </member>
        <member name="F:V8.Net.V8AccessControl.ProhibitsOverwriting">
            <summary>
            The accessor cannot be replaced by other contexts.
            </summary>
        </member>
        <member name="T:V8.Net.JSValueType">
            <summary>
            The type of JavaScript values marshalled from the native side.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.ExecutionTerminated">
            <summary>
            Script execution was terminated upon request.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.ExecutionError">
            <summary>
            An error has occurred while attempting to execute the compiled script.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.CompilerError">
            <summary>
            An error has occurred compiling the script (usually a syntax error).
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.InternalError">
            <summary>
            An internal error has occurred (before or after script execution).
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Uninitialized">
            <summary>
            The value has not been read yet from the native V8 handle, so a call to 'V8NetProxy.UpdateHandleValue(_HandleProxy)' is required.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Undefined">
            <summary>
            The value is undefined (no value set).  This is NOT the same as 'null'.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Script">
            <summary>
            The handle proxy represents pre-compiled JavaScript.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Null">
            <summary>
            The value is null (a null object reference).  This is NOT the same as 'undefined' (no value set).
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Bool">
            <summary>
            The value is a Boolean, as supported within JavaScript for true/false conditions.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.BoolObject">
            <summary>
            The value is a Boolean object (object reference), as supported within JavaScript when executing "new Boolean()".
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Int32">
            <summary>
            The value is a 32-bit Integer, as supported within JavaScript for bit operations.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Number">
            <summary>
            The value is a JavaScript 64-bit number.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.NumberObject">
            <summary>
            The value is a JavaScript 64-bit Number object (object reference), as supported within JavaScript when executing "new Number()".
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.String">
            <summary>
            The value is a UTF16 string.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.StringObject">
            <summary>
            The value is a JavaScript String object (object reference), as supported within JavaScript when executing "new String()".
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Object">
            <summary>
            The value is a non-value (object reference).
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Function">
            <summary>
            The value is a reference to a JavaScript function (object reference).
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Date">
            <summary>
            The date value is the number of milliseconds since epoch [1970-01-01 00:00:00 UTC+00] (a double value stored in 'Number').
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.Array">
            <summary>
            The value proxy represents a JavaScript array of various values.
            </summary>
        </member>
        <member name="F:V8.Net.JSValueType.RegExp">
            <summary>
            The value proxy represents a JavaScript regular expression object (object reference).
            </summary>
        </member>
        <member name="T:V8.Net.ProxyObjectType">
            <summary>
            Type of native proxy object (for native class instances only).
            </summary>
        </member>
        <member name="P:V8.Net.HandleProxy.IsActive">
            <summary>
            The handle is still in use.
            </summary>
        </member>
        <member name="P:V8.Net.HandleProxy.IsCLRDisposed">
            <summary>
            The handle has lost all managed side references and was marked weak on the native side.
            </summary>
        </member>
        <member name="P:V8.Net.HandleProxy.IsDisposing">
            <summary> The handle is queued for disposal. </summary>
        </member>
        <member name="P:V8.Net.HandleProxy.IsDisposed">
            <summary>
            The native persistent handle is disposed and cached.
            </summary>
        </member>
        <member name="T:V8.Net.ManagedNamedPropertyGetter">
            <summary>
            NamedProperty[Getter|Setter] are used as interceptors on object.
            See ObjectTemplate::SetNamedPropertyHandler.
            </summary>
        </member>
        <member name="T:V8.Net.ManagedNamedPropertySetter">
            <summary>
            Returns the value if the setter intercepts the request.
            Otherwise, returns an empty handle.
            </summary>
        </member>
        <member name="T:V8.Net.ManagedNamedPropertyQuery">
            <summary>
            Returns a non-empty value (>=0) if the interceptor intercepts the request.
            The result is an integer encoding property attributes (like v8::None,
            v8::DontEnum, etc.)
            </summary>
        </member>
        <member name="T:V8.Net.ManagedNamedPropertyDeleter">
            <summary>
            Returns a value indicating if the deleter intercepts the request.
            The return value is true (>0) if the property could be deleted and false (0)
            otherwise.
            </summary>
        </member>
        <member name="T:V8.Net.ManagedNamedPropertyEnumerator">
            <summary>
            Returns an array containing the names of the properties the named
            property getter intercepts.
            </summary>
        </member>
        <member name="T:V8.Net.ManagedIndexedPropertyGetter">
            <summary>
            Returns the value of the property if the getter intercepts __stdcall
            </summary>
        </member>
        <member name="T:V8.Net.ManagedIndexedPropertySetter">
            <summary>
            Returns the value if the setter intercepts the request.
            Otherwise, returns an empty handle.
            </summary>
        </member>
        <member name="T:V8.Net.ManagedIndexedPropertyQuery">
            <summary>
            Returns a non-empty value (>=0) if the interceptor intercepts the request.
            The result is an integer encoding property attributes.
            </summary>
        </member>
        <member name="T:V8.Net.ManagedIndexedPropertyDeleter">
            <summary>
            Returns a value indicating if the deleter intercepts the request.
            The return value is true (>0) if the property could be deleted and false (0)
            otherwise.
            </summary>
        </member>
        <member name="T:V8.Net.ManagedIndexedPropertyEnumerator">
            <summary>
            Returns an array containing the indices of the properties the
            indexed property getter intercepts.
            </summary>
        </member>
        <member name="T:V8.Net.NativeSetterAccessor">
            <summary>
            Returns the value if the setter intercepts the request.
            Otherwise, returns an empty handle.
            </summary>
        </member>
        <member name="T:V8.Net.NativeGetterAccessor">
            <summary>
            Returns the value if the setter intercepts the request.
            Otherwise, returns an empty handle.
            </summary>
        </member>
        <member name="T:V8.Net.V8GarbageCollectionRequestCallback">
            <summary>
            Intercepts a request to garbage collect a persistent V8 handle associated with the specified proxy handle.
            Return true to allow the collection, or false to prevent it.
            <para>Note: Internally, this is used to remove the strong reference to managed objects, leaving only a week one.</para>
            </summary>
        </member>
        <member name="M:V8.Net.Exceptions.GetFullErrorMessage(System.Exception,System.Boolean)">
            <summary>
            A simple utility method which formats and returns an exception error object.
            The stack trace is also included. The inner exceptions are also recursed and added.
            </summary>
            <param name="ex">The exception object with error message to format and return.</param>
        </member>
        <member name="T:V8.Net.ObservableWeakReference`1">
            <summary>
            Notifies handlers that an object is ready to be garbage collected.
            To use this you must 1. wrap it in your class and pass it your class reference, 2. override the finalize method for your class and call "Finalize"
            on this weak reference object, and 3. keep a strong reference to this weak reference object so you can check it later (if needed).
            <para>Warning: This event is triggered in the GC thread!</para>
            </summary>
            <typeparam name="T">The object type to keep a reference for.</typeparam>
        </member>
        <member name="E:V8.Net.ObservableWeakReference`1.GCReady">
            <summary>
            Triggered when the GC wants to collect the object.
            </summary>
        </member>
        <member name="P:V8.Net.ObservableWeakReference`1.IsGCReady">
            <summary>
            Is set to true when the GC wants to collect the object.
            </summary>
        </member>
        <member name="P:V8.Net.ObservableWeakReference`1.CanCollect">
            <summary>
            This is false by default, which prevents the object from being finalized in the garbage collection process.
            If you set this to true in an event handler, then upon return the object will continue being finalized.
            </summary>
        </member>
        <member name="P:V8.Net.ObservableWeakReference`1.Object">
            <summary>
            Returns a reference to the object wrapped by this instance.
            This is a weak reference at first, but will return the strong reference when the object is being finalized.
            <para>Note: The GC finalizer clears all weak references before running finalizers on all the objects, which means it's possible that main thread
            code may attempt to read this property, which would end up being 'null'.  However, this would be invalid, due to the fact 'DoFinalize()' hasn't been
            called yet.  To prevent this, this property is blocking (with a 1.5 second timeout) if the target is set to null by the finalizer, until the finalizer 
            triggers a call to 'DoFinalize()'.  As such, this property should never return 'null', unless a timeout occurs (may happen if viewed in a debugger).</para>
            </summary>
        </member>
        <member name="F:V8.Net.ObservableWeakReference`1.NullWaitEvent">
            <summary>
            When a finalizer runs on an object, the GC has already cleared all weak references. This means the main thread can read a null object reference
            before the callback has a chance to reset the reference.  To protect against this, any call on a null reference will block until this event has
            been signalled.
            </summary>
        </member>
        <member name="P:V8.Net.ObservableWeakReference`1.NearDeathReference">
            <summary>
            If 'IsGCReady' returns true, then this is the only reference that is keeping the object alive.
            </summary>
        </member>
        <member name="P:V8.Net.ObservableWeakReference`1.IsNearDeathReference">
            <summary>
            Returns true if an attempt was made to garbage collect the object (see <see cref="P:V8.Net.ObservableWeakReference`1.NearDeathReference"/>).
            </summary>
        </member>
        <member name="M:V8.Net.ObservableWeakReference`1.SetTarget(`0)">
            <summary>
            Changes the underlying target object of the internal weak reference instance.
            Warning: If the previous reference is "near death", it will be reset in order to set the new value.
            </summary>
        </member>
        <member name="M:V8.Net.ObservableWeakReference`1.Reset">
            <summary>
            If 'IsGCReady' is true, then this moves the near death reference back into the weak reference. If not, this method does nothing.
            <para>In either case, the underlying object is returned.</para>
            </summary>
        </member>
        <member name="M:V8.Net.ExtensionMethods.IsConstructedGenericType(System.Type)">
            <summary>
            '{Type}.IsConstructedGenericType' is only supported in .NET 4.5+, so this is a cross-version supported implementation.
            </summary>
        </member>
        <member name="M:V8.Net.ExtensionMethods.Join(System.Collections.IEnumerable,System.String)">
            <summary>
            Convert a list of enumerable items into strings and return the concatenated result.
            </summary>
        </member>
        <member name="M:V8.Net.Utilities.AllocNativeMemory(System.Int32)">
            <summary>
            Allocates native memory.
            </summary>
        </member>
        <member name="M:V8.Net.Utilities.AllocPointerArray(System.Int32)">
            <summary>
            Allocates native memory for storing pointers.
            </summary>
        </member>
        <member name="M:V8.Net.Utilities.FreeNativeMemory(System.IntPtr)">
            <summary>
            Frees native memory allocated with any of the 'Utilities.Alloc???()' methods.
            </summary>
        </member>
        <member name="M:V8.Net.Utilities.MakeHandleProxyArray``1(``0[])">
            <summary>
            Allocates native memory to marshal an array of proxy handles.
            Uses 'Utilities.AllocPointerArray()', so be sure to call 'Utilities.FreeNativeMemory()' when done.
            </summary>
        </member>
        <member name="M:V8.Net.Utilities.ND(System.Object,System.String)">
            <summary>
            Null Default (used mostly with database related data): Returns the value passed, or a default 
            value if the value passed is null, or equal to DBNull.Value.
            </summary>
            <param name="val">Value to check.</param>
            <param name="default_val">New value if "val" is null or DBNull.Value.</param>
            <returns></returns>
        </member>
        <member name="M:V8.Net.Strings.IsNullOrEmpty(System.Object)">
            <summary>
            Returns true if the given object is null, or its string conversion results in an empty/null string.
            </summary>
        </member>
        <member name="M:V8.Net.Strings.IsNullOrWhiteSpace(System.String)">
            <summary>
            Returns true if the string value is null or contains white space (contains all characters less than or equal Unicode value 32).
            </summary>
        </member>
        <member name="M:V8.Net.Strings.SelectNonEmptyString(System.String,System.String,System.String)">
            <summary>
            Selects the first non-null/empty string found in the parameter order given, and returns a default value if
            both are null/empty.
            </summary>
        </member>
        <member name="M:V8.Net.Strings.Join(System.String,System.Object[])">
            <summary>
            Convert a list of objects into strings and return the concatenated result.
            </summary>
        </member>
        <member name="M:V8.Net.Strings.Join(System.String[],System.String[])">
            <summary>
            Join two strings arrays into one big array. The new array is returned.
            </summary>
        </member>
        <member name="M:V8.Net.Strings.CopyTo(System.String[],System.String[],System.Int32)">
            <summary>
            Copies a given source string array into another (destination), returning the destination array.
            </summary>
            <param name="src">The array to copy.</param>
            <param name="dest">The target of the copy.</param>
            <param name="destIndex">The array index into the destination in which copy starts.</param>
        </member>
        <member name="M:V8.Net.Strings.Add(System.String,System.String[])">
            <summary>
            Copies the given string and string array to a new array. The new array is returned.
            </summary>
        </member>
        <member name="M:V8.Net.Strings.S(System.Int32,System.String,System.String,System.String)">
            <summary>
            Returns the singular or plural of a word based on a numerical value.
            </summary>
            <param name="value">Number value.</param>
            <param name="word">Base word, singular.</param>
            <param name="suffix_if_plural">Suffix to use if "value" is not 1.</param>
            <param name="numberFormatting">The number format, if any (optional).</param>
        </member>
        <member name="M:V8.Net.Strings.S(System.Double,System.String,System.String,System.String)">
            <summary>
            Returns the singular or plural of a word based on a numerical value.
            </summary>
            <param name="value">Number value.</param>
            <param name="word">Base word, singular.</param>
            <param name="suffix_if_plural">Suffix to use if "value" is not 1.</param>
            <param name="numberFormatting">The number format, if any (optional).</param>
        </member>
        <member name="M:V8.Net.Strings.Append(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Appends the source string to the target string and returns the result.
            If 'target' and 'source' are both not empty, then the delimiter is inserted between them, and the resulting string returned.
            </summary>
            <param name="target">The string to append to.</param>
            <param name="source">The string to append.</param>
            <param name="delimiter">If specified, the delimiter is placed between the target and source if the target is NOT empty.</param>
            <param name="onlyAddDelimiterIfMissing">Only inserts the delimiter if it is missing from the end of the target and beginning of the source.</param>
            <returns>The new string.</returns>
        </member>
        <member name="M:V8.Net.Strings.CharCount(System.String,System.Char)">
            <summary>
            Returns the number of occurrences of the given character in the given string.
            </summary>
            <param name="str">The string to look in.</param>
            <param name="chr">The character to count.</param>
        </member>
        <member name="M:V8.Net.Strings.TextEqual(System.String,System.String)">
            <summary>
            Performs a textual comparison, where the letter casing is ignored, and returns 'true' if the specified strings are a match.
            </summary>
            <param name="strA">The first string to compare.</param>
            <param name="strB">The second string to compare.</param>
        </member>
        <member name="M:V8.Net.Strings.Limit(System.String,System.UInt32,System.Boolean)">
            <summary>
            Returns the given string up to a maximum of 'maxlength' characters.
            If more than 'maxlength' characters exist, an ellipse character is appended to the returned substring.
            </summary>
        </member>
        <member name="M:V8.Net.Arrays.Concat``1(``0[][])">
            <summary>
            Concatenate a list of arrays. Specify one array for each parameter.
            To concatenate one list of arrays, use Join().
            </summary>
            <typeparam name="T">Array type for each argument.</typeparam>
            <param name="args">A concatenated array made form the specified arrays.</param>
            <returns></returns>
        </member>
        <member name="M:V8.Net.Arrays.Join``1(``0[][])">
            <summary>
            Concatenate a list of arrays.
            </summary>
            <typeparam name="T">Array type for each argument.</typeparam>
            <param name="arrays">A concatenated array made form the specified arrays.</param>
            <returns></returns>
        </member>
        <member name="M:V8.Net.Arrays.FromEnd``1(``0[],System.Int32)">
            <summary>
            Select an item from the end of the array.
            </summary>
            <typeparam name="T">Array type.</typeparam>
            <param name="items">The array.</param>
            <param name="index">0, or a negative value, that is the offset of the item to retrieve.</param>
        </member>
        <member name="M:V8.Net.Arrays.FromEnd``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Select an item from the end of the list.
            </summary>
            <typeparam name="T">List type.</typeparam>
            <param name="items">The list.</param>
            <param name="index">0, or a negative value, that is the offset of the item to retrieve.</param>
        </member>
        <member name="T:V8.Net.Types">
            <summary>
            Provides utility methods for types.
            This class was originally created to support the 'ThreadController" class's "Dispatch()" methods.
            </summary>
        </member>
        <member name="T:V8.Net.Types.Null">
            <summary>
            A structure which represents a 'typed' null value.
            This is required for cases where a type is just 'object', in which 'null' may be passed,
            but the type still needs to be known. An example usage is with methods that accept variable
            number of parameters, but need to know the argument type, even if null.
            </summary>
        </member>
        <member name="M:V8.Net.Types.Arg(System.Type,System.Object)">
            <summary>
            If not null, returns either the argument, otherwise returns argument's 'null' type.
            This is needed in cases where an argument is null, but the argument type is needed.
            <para>
            Example: MyMethod(typeof(DateTime).Arg(value)); - If 'value' is null, then the type is passed instead as 'Types.Null'
            </para>
            </summary>
            <param name="type">Argument type.</param>
            <param name="value">Argument value.</param>
            <returns>Argument value, or the type if null.</returns>
        </member>
        <member name="M:V8.Net.Types.GetTypes(System.Object[])">
            <summary>
            Attempts to get the types of the values passed.
            If a value is 'null', then the call will fail, and 'null' will be returned.
            Note: This method recognizes Types.Null values.
            </summary>
            <param name="args">Argument values to get types for.</param>
        </member>
        <member name="M:V8.Net.Types.ConvertNullsToNullReferences(System.Object[])">
            <summary>
            Converts any Types.Null objects into simple 'null' references.
            This is helpful after using Types.GetTypes() on the same items - once the types are
            retrieved, this method helps to convert Types.Null items back to 'null'.
            </summary>
        </member>
        <member name="T:V8.Net.V8Engine">
            <summary>
            Creates a new managed V8Engine wrapper instance and associates it with a new native V8 engine.
            The engine does not implement locks, so to make it thread safe, you should lock against an engine instance (i.e. lock(myEngine){...}).  The native V8
            environment, however, is thread safe (but blocks to allow only one thread at a time).
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.RunMarshallingTests">
            <summary>
            If there's any marshalling incompatibility, this will throw an exception.
            </summary>
        </member>
        <member name="F:V8.Net.V8Engine.DefaultMemberBindingSecurity">
            <summary>
            This is a global setting for this engine instance for binding members of types that do not have one of the 'ScriptObject' or 'ScriptMember' security attributes.
            Using this default security, if you call a function in script that returns an unregistered managed type, the type will be available by reference only,
            and no members will be bound (no properties will exist).
            </summary>
        </member>
        <member name="F:V8.Net.V8Engine._Binders">
            <summary>
            Holds a list of all binders that can operate on an instance of a given type.
            </summary>
        </member>
        <member name="F:V8.Net.V8Engine._RegisteredTypes">
            <summary>
            Provides an ID for each registered type binder for internal use (to prevent having to re-construct the type object more than once).
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.IsTypeRegistered(System.Type)">
            <summary>
            Returns true if a binding exists for the specified type.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.RegisterType(System.Type,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Registers binding related schema for the given type on top an 'ObjectTemplate' instance.  If a type already exists that doesn't match the given parameters, it is replaced.
            <para>This is done implicitly, so there's no need to register types before binding them; however, explicitly registering a type using this
            method gives the user more control over the behaviour of the binding process.</para>
            </summary>
            <param name="type">The type to create and cache a binding for.</param>
            <param name="className">A custom in-script function name for the specified type, or 'null' to use either the type name as is (the default), or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">When an object is bound, only the object instance itself is bound (and not any reference members). If true, then nested object references are included.</param>
            <param name="memberSecurity">Default member attributes for members that don't have the 'ScriptMember' attribute.</param>
        </member>
        <member name="M:V8.Net.V8Engine.RegisterType``1(System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Registers a binding for the given type.  If a type already exists that doesn't match the given parameters, it is replaced.
            <para>This is done implicitly, so there's no need to register types before binding them; however, explicitly registering a type using this
            method gives the user more control over the behaviour of the binding process.</para>
            </summary>
            <typeparam name="T">The type to create and cache a binding for.</typeparam>
            <param name="className">A custom in-script function name for the specified type, or 'null' to use either the type name as is (the default), or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">When an object is bound, only the object instance itself is bound (and not any reference members). If true, then nested object references are included.</param>
            <param name="memberSecurity">Default member attributes for members that don't have the 'ScriptMember' attribute.</param>
        </member>
        <member name="M:V8.Net.V8Engine.GetTypeBinder(System.Type)">
            <summary>
            Returns the TypeBinder for the given type.  If nothing is found, 'null' will be returned.
            </summary>
            <param name="type">The type to search for.</param>
        </member>
        <member name="M:V8.Net.V8Engine.CreateBinding(System.Type,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Creates a binding for a given CLR type to expose it in the JavaScript environment.
            The type returned is a function (V8Function) object that can be used to create the underlying type.
            <para>Note: Creating bindings is a much slower process than creating your own function templates.</para>
            </summary>
            <param name="className">A custom type name, or 'null' to use either the type name as is (the default), or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">When an object type is instantiate within JavaScript, only the object instance itself is bound (and not any reference members).
            If true, then nested object references are included.</param>
            <param name="memberSecurity">Default member attributes for members that don't have the 'ScriptMember' attribute.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:V8.Net.V8Engine.CreateBinding``1(System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})" -->
        <member name="M:V8.Net.V8Engine.CreateBinding(System.Object,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity},System.Boolean)">
            <summary>
            Creates a binding for a given CLR object instance to expose it in the JavaScript environment (sub-object members are not bound however).
            If the object given is actually a boxed primitive type, then a non-object handle can be returned.
            If the given object is not a boxed value, then the handle returned is a handle to an object binder with internal property
            accessors for the encapsulated object's public fields, properties, and methods.
            <para>Note: Creating bindings can be a much slower process than creating your own 'V8NativeObject' types; however, 
            bound types are cached and not created each time for the best efficiency.</para>
            </summary>
            <param name="obj">The object to create a binder for.</param>
            <param name="className">A custom type name, or 'null' to use either the type name as is (the default), or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">When an object type is instantiate within JavaScript, only the object instance itself is bound (and not any reference members).
            If true, then nested object references are included.</param>
            <param name="memberSecurity">Default member attributes for members that don't have the 'ScriptMember' attribute.</param>
            <param name="initializeBinder">If true (default) then 'IV8NativeObject.Initialize()' is called on the created object before returning.</param>
        </member>
        <member name="F:V8.Net.V8Engine._HandleProxies">
            <summary>
            Holds an index of all handles created for this engine instance.
            This is a managed side reference to all the active and cached native side handle wrapper (proxy) objects.
            </summary>
        </member>
        <member name="F:V8.Net.V8Engine._TrackerHandles">
            <summary>
            When a new managed side handle wraps a native handle proxy the disposal process happens internally in a controlled 
            manor.  There is no need to burden the end user with tracking handles for disposal, so when a handle enters public
            space, it is assigned a 'HandleTracker' object reference from this list.  If not available, one is created.
            For instance, during a callback, all native arguments (proxy references) are converted into handle values (which in
            many cases means on the stack, or CPU registers, instead of the heap; though this is CLR implementation dependent).
            These are then passed on to the user callback method WITHOUT a handle tracker, and disposed automatically on return.
            This can save creating many unnecessary objects for the managed GC to deal with.
            </summary>
        </member>
        <member name="P:V8.Net.V8Engine.Handles_All">
            <summary>
            Returns all the handles currently known on the managed side.
            Each InternalHandle is only a wrapper for a tracked HandleProxy native object and does not need to be disposed.
            Because of this, no reference counts are incremented, and thus, disposing them may destroy handles in use.
            This list is mainly provided for debugging purposes only.
            </summary>
        </member>
        <member name="P:V8.Net.V8Engine.TotalHandles">
            <summary>
            Total number of handle proxy references in the V8.NET system (for proxy use).
            </summary>
        </member>
        <member name="P:V8.Net.V8Engine.TotalHandlesPendingDisposal">
            <summary>
            Total number of handle proxy references that are in a native side queue for disposal.
            </summary>
        </member>
        <member name="P:V8.Net.V8Engine.TotalHandlesCached">
            <summary>
            Total number of handles in the V8.NET system that are cached and ready to be reused.
            </summary>
        </member>
        <member name="P:V8.Net.V8Engine.TotalHandlesInUse">
            <summary>
            Total number of handles in the V8.NET system that are currently in use.
            </summary>
        </member>
        <member name="F:V8.Net.V8Engine._Objects">
            <summary>
            Holds an index of all the created objects.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine._CreateManagedObject``1(V8.Net.ITemplate,V8.Net.InternalHandle,System.Boolean)">
            <summary>
            Creates an uninitialized managed object ONLY (does not attempt to associate it with a JavaScript object, regardless of the supplied handle).
            <para>Warning: The managed wrapper is not yet initialized.  When returning the new managed object to the user, make sure to call
            '_ObjectInfo.Initialize()' first. Note however that new objects should only be initialized AFTER setup is completed so the users
            (developers) can write initialization code on completed objects (see source as example for 'FunctionTemplate.GetFunctionObject()').</para>
            </summary>
            <typeparam name="T">The wrapper type to create (such as V8ManagedObject).</typeparam>
            <param name="template">The managed template reference that owns the native object, if applicable.</param>
            <param name="handle">The handle to the native V8 object.</param>
            <param name="connectNativeObject">If true (the default), then a native function is called to associate the native V8 object with the new managed object.
            Set this to false if native V8 objects will be associated manually for special cases.  This parameter is ignored if no handle is given (hNObj == null).</param>
        </member>
        <member name="M:V8.Net.V8Engine.GetObject``1(V8.Net.InternalHandle,System.Boolean,System.Boolean)">
            <summary>
            Gets the managed object that wraps the native V8 object for the specific handle.
            <para>Warning: You MUST pass a handle for objects only created from this V8Engine instance, otherwise you may get errors, or a wrong object (without error).</para>
            </summary>
            <typeparam name="T">You can derive your own object from V8NativeObject, or implement IV8NativeObject yourself.
            In either case, you can specify the type here to have it created for new object handles.</typeparam>
            <param name="handle">A handle to a native object that contains a valid managed object ID.</param>
            <param name="createIfNotFound">If true, then an IV8NativeObject of type 'T' will be created if an existing IV8NativeObject object cannot be found, otherwise 'null' is returned.</param>
            <param name="initializeOnCreate">If true (default) then then 'IV8NativeObject.Initialize()' is called on the created wrapper.</param>
        </member>
        <member name="M:V8.Net.V8Engine.GetObject(V8.Net.InternalHandle,System.Boolean,System.Boolean)">
            <summary>
            Returns a 'V8NativeObject' or 'V8Function' object based on the handle.
            <see cref="M:V8.Net.V8Engine.GetObject``1(V8.Net.InternalHandle,System.Boolean,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine._GetObject``1(V8.Net.ITemplate,V8.Net.InternalHandle,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Same as "GetObject()", but used internally for getting objects that are associated with templates (such as getting function prototype objects).
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.GetObjectByID(System.Int32)">
            <summary>
            Returns an object based on its ID (an object ID is simply an index value, so the lookup is fast, but it does not protect the object from
            garbage collection).
            <para>Note: If the ID is invalid, or the managed object has been garbage collected, then this will return null (no errors will occur).</para>
            <para>WARNING: Do not rely on this method unless you are sure the managed object is persisted. It's very possible for an object to be deleted and a
            new object put in the same place as identified by the same ID value. As long as you keep a reference/handle, or perform no other V8.NET actions
            between the time you read an object's ID, and the time this method is called, then you can safely use this method.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.GetObjects(System.Func{V8.Net.V8NativeObject,System.Boolean})">
            <summary>
            Returns all the objects using a filter expression. If no expression is given, all objects will be included.
            <para>Warning: This method enumerates using 'yield return' while keeping a read lock on the internal V8NativeObject 
            WeakReference collection. It is recommended to dump the results to an array or list if enumeration will be deferred
            at any point.</para>
            </summary>
        </member>
        <member name="F:V8.Net.V8Engine.Epoch">
            <summary>
            Set to the fixed date of Jan 1, 1970. This is used when converting DateTime values to JavaScript Date objects.
            </summary>
        </member>
        <member name="P:V8.Net.V8Engine.Engines">
            <summary>
            A static array of all V8 engines created.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.#ctor(System.Boolean)">
            <summary> V8Engine constructor. </summary>
            <param name="autoCreateGlobalContext">
                (Optional) True to automatically create a global context. If this is false then you must construct a context
                yourself before executing JavaScript or calling methods that require contexts.
            </param>
        </member>
        <member name="P:V8.Net.V8Engine.IsDisposed">
            <summary>
            Returns true once this engine has been disposed.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.SetFlagsFromString(System.String)">
            <summary>
            Sets V8 command line options.
            </summary>
            <param name="flags">Command line options/flags separated by a space.</param>
        </member>
        <member name="M:V8.Net.V8Engine.SetFlagsFromCommandLine(System.String[])">
            <summary>
            Sets V8 command line options.
            <para>Just a convenient way to call 'SetFlagsFromString()' by joining all strings together, delimited by a space.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.ForceV8GarbageCollection">
            <summary>
                Calling this method forces a native call to 'LowMemoryNotification()' and 'IdleNotificationDeadline()' to push the
                V8 engine to complete garbage collection tasks. The work performed helps to reduce the memory footprint within the
                native V8 engine.
                <para>(See also: <seealso cref="M:V8.Net.V8Engine.DoIdleNotification(System.Int32)"/>)</para>
                <para>Note: You CANNOT GC CLR objects using this method.  This only applies to collection of native V8 handles that
                are no longer in use. To *force* the disposal of an object, do this: "{Handle}.ReleaseManagedObject();
                {Handle}.Dispose(); GC.Collect();
                "</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.DoIdleNotification(System.Int32)">
            <summary>
                Calling this method notifies the native V8 engine to perform work tasks before returning. The delay is the amount of
                time given to V8 to complete it's tasks, such as garbage collection. The work performed helps to reduce the memory
                footprint within V8. This helps the garbage collector know when to start collecting objects and values that are no
                longer in use. A true returned value indicates that V8 has done as much cleanup as it will be able to do.
                <para>(See also: <seealso cref="M:V8.Net.V8Engine.ForceV8GarbageCollection"/>)</para>
            </summary>
            <param name="delay">
                (Optional) The amount of time, in seconds, allocated to the V8 GC to run some tasks, such as garbage collection.
                V8.Net defaults this to 1 second.
            </param>
            <returns> False if more work is pending, and true when all work is completed (nothing more to do). </returns>
        </member>
        <member name="M:V8.Net.V8Engine.Execute(System.String,System.String,System.Boolean,System.Int32,System.Boolean)">
            <summary> Executes JavaScript on the V8 engine and returns the result. </summary>
            <param name="script"> The script to run. </param>
            <param name="sourceName">
                (Optional) A string that identifies the source of the script (handy for debug purposes).
            </param>
            <param name="throwExceptionOnError">
                (Optional) If true, and the return value represents an error, an exception is thrown (default is 'false').
            </param>
            <param name="timeout">
                (Optional) The amount of time, in milliseconds, to delay before 'TerminateExecution()' is invoked.
            </param>
            <param name="trackReturn">
                (Optional) True to add a tracking object to the handle so the GC disposes of the native side automatically. Setting
                this to false means you take full responsibility to dispose this manually. This also adds a very small speed boost
                since no tracking is required.
            </param>
            <returns> An InternalHandle. </returns>
        </member>
        <member name="M:V8.Net.V8Engine.Execute(V8.Net.InternalHandle,System.Boolean,System.Int32)">
            <summary> Executes JavaScript on the V8 engine and returns the result. </summary>
            <exception cref="T:System.InvalidOperationException"> Thrown when the requested operation is invalid. </exception>
            <param name="script"> The script to run. </param>
            <param name="throwExceptionOnError">
                (Optional) If true, and the return value represents an error, an exception is thrown (default is 'false').
            </param>
            <param name="timeout">
                (Optional) The amount of time, in milliseconds, to delay before 'TerminateExecution()' is invoked.
            </param>
            <returns> An InternalHandle. </returns>
        </member>
        <member name="M:V8.Net.V8Engine.ConsoleExecute(System.String,System.String,System.Boolean,System.Int32)">
            <summary>
                Executes JavaScript on the V8 engine and automatically writes the result to the console (only valid for applications
                that support 'Console' methods).
                <para>Note: This is just a shortcut to calling 'Execute()' followed by 'Console.WriteLine()'.</para>
            </summary>
            <param name="script"> The script to run. </param>
            <param name="sourceName">
                (Optional) A string that identifies the source of the script (handy for debug purposes).
            </param>
            <param name="throwExceptionOnError">
                (Optional) If true, and the return value represents an error, an exception is thrown (default is 'false').
            </param>
            <param name="timeout">
                (Optional) The amount of time, in milliseconds, to delay before 'TerminateExecution()' is invoked.
            </param>
            <returns> The result of the executed script. </returns>
        </member>
        <member name="M:V8.Net.V8Engine.VerboseConsoleExecute(System.String,System.String,System.Boolean,System.Int32)">
            <summary>
                Executes JavaScript on the V8 engine and automatically writes the script given AND the result to the console (only
                valid for applications that support 'Console' methods). The script is output to the console window before it gets
                executed.
                <para>Note: This is just a shortcut to calling 'Console.WriteLine(script)', followed by 'ConsoleExecute()'.</para>
            </summary>
            <param name="script"> The script to run. </param>
            <param name="sourceName">
                (Optional) A string that identifies the source of the script (handy for debug purposes).
            </param>
            <param name="throwExceptionOnError">
                (Optional) If true, and the return value represents an error, an exception is thrown (default is 'false').
            </param>
            <param name="timeout">
                (Optional) The amount of time, in milliseconds, to delay before 'TerminateExecution()' is invoked.
            </param>
            <returns> The result of the executed script. </returns>
        </member>
        <member name="M:V8.Net.V8Engine.Compile(System.String,System.String,System.Boolean)">
            <summary>
                Compiles JavaScript on the V8 engine and returns the result. Since V8 JIT-compiles script every time, repeated tasks
                can take advantage of re-executing pre-compiled scripts for a speed boost.
            </summary>
            <param name="script"> The script to run. </param>
            <param name="sourceName">
                (Optional) A string that identifies the source of the script (handy for debug purposes).
            </param>
            <param name="throwExceptionOnError">
                (Optional) If true, and the return value represents an error, an exception is thrown (default is 'false').
            </param>
            <returns> A handle to the compiled script. </returns>
        </member>
        <member name="M:V8.Net.V8Engine.TerminateExecution">
            <summary>
            Forcefully terminate the current thread of JavaScript execution.
            This method can be used by any thread. 
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.LoadScript(System.String,System.String,System.Boolean)">
            <summary>
            Loads a JavaScript file from the current working directory (or specified absolute path) and executes it in the V8 engine, then returns the result.
            </summary>
            <param name="scriptFile">The script file to load.</param>
            <param name="sourceName">A string that identifies the source of the script (handy for debug purposes).</param>
            <param name="throwExceptionOnError">If true, and the return value represents an error, or the file fails to load, an exception is thrown (default is 'false').</param>
        </member>
        <member name="M:V8.Net.V8Engine.LoadScriptCompiled(System.String,System.String,System.Boolean)">
            <summary>
            Loads a JavaScript file from the current working directory (or specified absolute path) and compiles it in the V8 engine, then returns the compiled script.
            You will need to call 'Execute(...)' with the script handle to execute it.
            </summary>
            <param name="scriptFile">The script file to load.</param>
            <param name="sourceName">A string that identifies the source of the script (handy for debug purposes).</param>
            <param name="throwExceptionOnError">If true, and the return value represents an error, or the file fails to load, an exception is thrown (default is 'false').</param>
        </member>
        <member name="M:V8.Net.V8Engine.CreateObjectTemplate``1(System.Boolean)">
            <summary>
            Creates a new native V8 ObjectTemplate and associates it with a new managed ObjectTemplate.
            <para>Object templates are required in order to generate objects with property interceptors (that is, all property access is redirected to the managed side).</para>
            </summary>
            <param name="registerPropertyInterceptors">If true (default) then property interceptors (call-backs) will be used to support 'IV8ManagedObject' objects.
            <para>Note: Setting this to false provides a huge performance increase because all properties will be stored on the native side only (but 'IV8ManagedObject'
            objects created by this template will not intercept property access).</para></param>
            <typeparam name="T">Normally this is always 'ObjectTemplate', unless you have a derivation of it.</typeparam>
        </member>
        <member name="M:V8.Net.V8Engine.CreateObjectTemplate">
            <summary>
            Creates a new native V8 ObjectTemplate and associates it with a new managed ObjectTemplate.
            <para>Object templates are required in order to generate objects with property interceptors (that is, all property access is redirected to the managed side).</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateFunctionTemplate``1(System.String)">
            <summary>
            Creates a new native V8 FunctionTemplate and associates it with a new managed FunctionTemplate.
            <para>Function templates are required in order to associated managed delegates with JavaScript functions within V8.</para>
            </summary>
            <typeparam name="T">Normally this is always 'FunctionTemplate', unless you have a derivation of it.</typeparam>
            <param name="className">The "class name" in V8 is the type name returned when "valueOf()" is used on an object. If this is null then 'V8Function' is assumed.</param>
            <param name="callbackSource">A delegate to call when the function is executed.</param>
        </member>
        <member name="M:V8.Net.V8Engine.CreateFunctionTemplate(System.String)">
            <summary>
            Creates a new native V8 FunctionTemplate and associates it with a new managed FunctionTemplate.
            <para>Function templates are required in order to associated managed delegates with JavaScript functions within V8.</para>
            </summary>
            <param name="className">The "class name" in V8 is the type name returned when "valueOf()" is used on an object. If this is null (default) then 'V8Function' is assumed.</param>
            <param name="callbackSource">A delegate to call when the function is executed.</param>
        </member>
        <member name="M:V8.Net.V8Engine.CreateContext(V8.Net.ObjectTemplate)">
            <summary>
                Calls the native V8 proxy library to create a new context environment for use with executing JavaScript.
            </summary>
            <param name="globalTemplate"> (Optional) An optional global template (if null one will be created automatically). </param>
            <returns> A context wrapper the references the native V8 context. </returns>
        </member>
        <member name="M:V8.Net.V8Engine.SetContext(V8.Net.Context)">
            <summary>
                Changes the V8 proxy engine context to a new execution context. Each context can be used as a "sandbox" to isolate
                executions from one another. This method also returns the global object handle associated with the context.
                <para>In the normal "V8" way, you enter a context before executing JavaScript, then exit a context when done.  To
                limit the overhead of calling from managed methods into native functions for entering and exiting contexts all the
                time, V8.Net instead sets the current context on a native V8 engine proxy so all future calls use the new context.
                The context will be entered and exited automatically on the native side as needed. </para>
            </summary>
            <param name="context"> The new context to set. </param>
            <returns> An InternalHandle. </returns>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.Boolean)">
            <summary>
            Calls the native V8 proxy library to create the value instance for use within the V8 JavaScript environment.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.Int32)">
            <summary>
            Calls the native V8 proxy library to create a 32-bit integer for use within the V8 JavaScript environment.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.Double)">
            <summary>
            Calls the native V8 proxy library to create a 64-bit number (double) for use within the V8 JavaScript environment.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.String)">
            <summary>
            Calls the native V8 proxy library to create a string for use within the V8 JavaScript environment.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateError(System.String,V8.Net.JSValueType)">
            <summary>
            Calls the native V8 proxy library to create an error string for use within the V8 JavaScript environment.
            <para>Note: The error flag exists in the associated proxy object only.  If the handle is passed along to another operation, only the string message will get passed.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.TimeSpan)">
            <summary>
            Calls the native V8 proxy library to create a date for use within the V8 JavaScript environment.
            </summary>
            <param name="ms">The number of milliseconds since epoch (Jan 1, 1970). This is the same value as 'SomeDate.getTime()' in JavaScript.</param>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.DateTime)">
            <summary>
            Calls the native V8 proxy library to create a date for use within the V8 JavaScript environment.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine._CreateObject``1(V8.Net.ITemplate,V8.Net.InternalHandle,System.Boolean,System.Boolean)">
            <summary>
            Wraps a given object handle with a managed object, and optionally associates it with a template instance.
            <para>Note: Any other managed object associated with the given handle will cause an error.
            You should check '{Handle}.HasManagedObject', or use the "GetObject()" methods to make sure a managed object doesn't already exist.</para>
            <para>This was method exists to support the following cases: 1. The V8 context auto-generates the global object, and
            2. V8 function objects are not generated from templates, but still need a managed wrapper.</para>
            <para>Note: </para>
            </summary>
            <typeparam name="T">The wrapper type to create (such as V8ManagedObject).</typeparam>
            <param name="v8Object">A handle to a native V8 object.</param>
            <param name="initialize">If true (default) then then 'IV8NativeObject.Initialize()' is called on the created object before returning.</param>
        </member>
        <member name="M:V8.Net.V8Engine.CreateObject``1(V8.Net.InternalHandle,System.Boolean)">
            <summary>
            Wraps a given object handle with a managed object.
            <para>Note: Any other managed object associated with the given handle will cause an error.
            You should check '{Handle}.HasManagedObject', or use the "GetObject()" methods to make sure a managed object doesn't already exist.</para>
            <para>This was method exists to support the following cases: 1. The V8 context auto-generates the global object, and
            2. V8 function objects are not generated from templates, but still need a managed wrapper.</para>
            <para>Note: </para>
            </summary>
            <typeparam name="T">The wrapper type to create (such as V8ManagedObject).</typeparam>
            <param name="v8Object">A handle to a native V8 object.</param>
            <param name="initialize">If true (default) then then 'IV8NativeObject.Initialize()' is called on the created object before returning.</param>
        </member>
        <member name="M:V8.Net.V8Engine.CreateObject(V8.Net.InternalHandle,System.Boolean)">
            <summary>
            See <see cref="M:V8.Net.V8Engine.CreateObject``1(V8.Net.InternalHandle,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateObject``1(System.Boolean)">
            <summary>
            Creates a new CLR object which will be tracked by a new V8 native object.
            </summary>
            <param name="initialize">If true (default) then then 'IV8NativeObject.Initialize()' is called on the created wrapper before returning.</param>
            <typeparam name="T">A custom 'V8NativeObject' type, or just use 'V8NativeObject' as a default.</typeparam>
        </member>
        <member name="M:V8.Net.V8Engine.CreateObject">
            <summary>
            Creates a new native V8 object only.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateArray(V8.Net.InternalHandle[])">
            <summary>
            Calls the native V8 proxy library to create a JavaScript array for use within the V8 JavaScript environment.
            <para>Note: The given handles are not disposed, and the caller is still responsible.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Converts an enumeration of values (usually from a collection, list, or array) into a JavaScript array.
            By default, an exception will occur if any type cannot be converted.
            </summary>
            <param name="enumerable">An enumerable object to convert into a native V8 array.</param>
            <returns>A native V8 array.</returns>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Calls the native V8 proxy library to create the value instance for use within the V8 JavaScript environment.
            <para>This overload provides a *quick way* to construct an array of strings.
            One big memory block is created to marshal the given strings at one time, which is many times faster than having to create an array of individual native strings.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateNullValue">
            <summary>
            Simply creates and returns a 'null' JavaScript value.
            </summary>
        </member>
        <member name="M:V8.Net.V8Engine.CreateValue(System.Object,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Creates a native V8 JavaScript value that the best represents the given managed value.
            Object instance values will be bound to a 'V8NativeObject' wrapper and returned.
            To include implicit wrapping of object-type fields and properties for object instances, set 'recursive' to true, otherwise they will be skipped.
            <para>Warning: Integers are 32-bit, and Numbers (double) are 64-bit.  This means converting 64-bit integers may result in data loss.</para>
            </summary>
            <param name="value">One of the supported value types: bool, byte, Int16-64, Single, float, double, string, char, StringBuilder, DateTime, or TimeSpan. (Warning: Int64 will be converted to Int32 [possible data loss])</param>
            <param name="recursive">For object instances, if true, then nested objects are included, otherwise only the object itself is bound and returned.
            For security reasons, public members that point to object instances will be ignored. This must be true to included those as well, effectively allowing
            in-script traversal of the object reference tree (so make sure this doesn't expose sensitive methods/properties/fields).</param>
            <param name="memberSecurity">For object instances, these are default flags that describe JavaScript properties for all object instance members that
            don't have any 'ScriptMember' attribute.  The flags should be 'OR'd together as needed.</param>
            <returns>A native value that best represents the given managed value.</returns>
        </member>
        <member name="T:V8.Net.Handle">
            <summary>
            Wrapper to an InternalHandle value for GC tracking purposes.  Calls work internally using 'InternalHandle' for
            efficiency; however, an object handle is needed outside of V8.Net for end users. To prevent creating many objects
            for the same native V8 handle, 'Handle' objects are stored in a fixed size array for quick lookup, and are shared
            across many InternalHandle values. When all InternalHandle values are gone, this handle gets collected, unless
            also referenced.
            </summary>
        </member>
        <member name="P:V8.Net.Handle._">
            <summary>
            Just another shorter way to return the 'InternalHandle' value.
            <para>Note: You can also prefix a tilde ('~') character to a 'Handle' reference to de-reference it to the underlying
            InternHandle value as well (i.e. '(~handle).SetProperty(...)', or 'var h = ~handle; h.Call(...)').</para>
            </summary>
        </member>
        <member name="M:V8.Net.Handle.Finalize">
            <summary>
                This is called on the GC finalizer thread to flag that this managed object entry can be collected. This is done by
                marking the native side handle as weak. If a script is running during this call then the native side will detect it 
                and queue the request for later.
                <para>Note: There are no longer any managed references to the object at this point; HOWEVER, there may still be
                NATIVE ones. This means the native object may survive this process.</para>
            </summary>
        </member>
        <member name="P:V8.Net.Handle.IsError">
            <summary>
            Returns true if this handle contains an error message (the string value is the message).
            If you have exception catching in place, you can simply call 'ThrowOnError()' instead.
            </summary>
        </member>
        <member name="M:V8.Net.Handle.ThrowOnError">
            <summary>
            Checks if the handle represents an error, and if so, throws one of the corresponding derived V8Exception exceptions.
            See 'JSValueType' for possible exception states.  You can check the 'IsError' property to see if this handle represents an error.
            <para>Exceptions thrown: V8InternalErrorException, V8CompilerErrorException, V8ExecutionErrorException, and V8Exception (for any general V8-related exceptions).</para>
            </summary>
        </member>
        <member name="P:V8.Net.Handle.Engine">
            <summary>
            Returns a reference to the engine this tracker handle belongs to.
            </summary>
        </member>
        <member name="P:V8.Net.Handle.CanDispose">
            <summary>
                Returns true if calling 'Dispose()' will release the native side handle immediately on the native side. All
                InternalHandle values not kept alive can be disposed quickly.  The only handle left on a managed object cannot be
                disposed, nor the global object handle, as these will be locked. If false is returned, then there is a managed
                object associated.
                <para>This may be overridden in derived types, such as <see cref="T:V8.Net.V8NativeObject"/>.</para>
            </summary>
            <value> A true or false value. </value>
            <seealso cref="P:V8.Net.IV8Disposable.CanDispose"/>
        </member>
        <member name="M:V8.Net.Handle.Dispose">
            <summary>
                Disposes of the underlying native handle. If the handle cannot be disposed (perhaps because it is locked), an
                <see cref="T:System.InvalidOperationException"/> error will occur. Optionally you may find 'TryDispose()' more convenient to ignore such
                situations.
                <para>
                If the handle represents a managed V8NativeObject instance, the handle cannot be disposed externally. Managed
                objects will begin a disposal process when there are no more managed references. When this occurs, the native side
                V8 handle is made "weak".  When there are no more references in V8, the V8's GC calls back into the managed side to
                notify that disposal can complete. In all other cases, disposing a handle will succeed.
                </para>
            </summary>
        </member>
        <member name="M:V8.Net.Handle.TryDispose">
            <summary>
            Same as 'Dispose()', except that any errors are suppressed (i.e. if the handle is locked). 
            If successful (which usually just means this handle was cleared), then 'true' is returned.
            </summary>
        </member>
        <member name="P:V8.Net.Handle.InternalHandle">
            <summary>
            Returns a the underlying InternalHandle value.
            </summary>
        </member>
        <member name="T:V8.Net.InternalHandle">
            <summary>
            Keeps track of native V8 handles (C++ native side).
            <para>DO NOT STORE THIS HANDLE. Use "Handle" instead (i.e. "Handle h = someInternalHandle;"), or use the value with the "using(someInternalHandle){}" statement.</para>
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.GetUntrackedHandleFromInternal(V8.Net.InternalHandle)">
            <summary>
                Returns a handle that initially does not have any trackers associated, and only references the underlying native
                proxy handle object.  This can be useful for "watching" the proxy handle. For example, in testing garbage collection,
                one can test IsDisposed, IsDisposing, or IsNativelyWeak without blocking the GC collection due to a reference of any
                associated managed object in the handle.
                <para>Warning: Tracker handles are shared via index IDs on a global array in the engine.  As such, accessing certain
                properties and methods on the untracked handle can trigger a pull to update the untracked handle with the tracker.
                Normally this is not a problem, unless one is testing the GC, as it may prevent the GC from collecting the object
                during the test.</para>
            </summary>
        </member>
        <member name="F:V8.Net.InternalHandle._Object">
            <summary>
            The managed object represented by this handle, if any, or null otherwise.
            If this handle does not represent a managed object, then this may be set to a 'Handle' instead to allow tracking 
            and disposing the internal handle value within external user code.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.KeepTrack">
            <summary>
                InternalHandle values are disposed within the engine system automatically.  If a handle is to be used outside the
                engine, this should be called to allow the handle to be tracked by the managed GC.
                <para>Note: This should usually only need to be called on handles returned from methods on the engine.  This is not
                called by default on handles passed into callbacks, as those handles are disposed automatically upon return from the
                callback.  When a callback completes, the native side calls '{HandleProxy}.TryDispose()' to try to dispose handles
                (such as those for arguments) automatically. This method must be called to prevent those handles from being
                disposed. If not called, and you store the handle value, you'll get an error if you try to use it later.</para>
            </summary>
            <returns> The current handle. </returns>
        </member>
        <member name="M:V8.Net.InternalHandle.KeepAlive">
            <summary>
                When objects are created a weak reference is kept in order to translate object IDs into references. This means
                however that objects are not "rooted" by default, and unless you have your own reference, the object will eventually
                get reclaimed by the garbage collector (GC).  The side-effect is that objects on the native side no longer show any
                connection to the managed side.  To prevent this, either keep your own reference, or call this method. This is
                called on <see cref="T:V8.Net.ObjectBinder"/> objects automatically, since they are usually created within script.
                <para>Note: The native side handle will be made weak.  As soon as the native side tries to garbage collect the
                object, the internal rooted reference will be removed.</para>
                If the associated object is no longer needed, you can call <see cref="M:V8.Net.InternalHandle.Abandon"/> so the native V8 GC will dispose of
                it on it's own.
            </summary>
            <returns> The current handle. </returns>
            <seealso cref="M:V8.Net.InternalHandle.Abandon"/>
        </member>
        <member name="M:V8.Net.InternalHandle.Abandon">
            <summary>
                If the object is no longer needed, you can call this so the native V8 GC can dispose of the managed object on it's
                own (via a native GC callback that V8.Net hooks into). This is normally done if <see cref="M:V8.Net.InternalHandle.KeepAlive"/> was
                previously called, which permanently roots managed objects to prevent the managed GC from claiming them.
            </summary>
            <returns> An InternalHandle. </returns>
            <seealso cref="M:V8.Net.InternalHandle.KeepAlive"/>
        </member>
        <member name="M:V8.Net.InternalHandle.GetTrackableHandle(System.Boolean)">
            <summary>
            Returns a 'Handle' instance that can be used to track this value-based handle.  When no more value-based handles
            exist, including any references to the tracker itself, the tracker will initiate disposal of the native proxy
            handle. Calling 'KeepAlive()' implicitly calls this method as well.
            </summary>
            <param name="createIfMissing">If true (default), then a tracker handle based object is created if one doesn't exist
            yet.  If false, then a tracker is only returned if one already exists, otherwise null is returned.
            <para>Tracker handles are objects, instead of values, and are used to dispose of value base handles via the garbage
            collector. This method is called implicitly when converting from an InternalHandle value to a Handle type.</para>
            </param>
        </member>
        <member name="M:V8.Net.InternalHandle.#ctor(V8.Net.HandleProxy*,System.Boolean)">
            <summary>
            Wraps a given native handle proxy to provide methods to operate on it.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.#ctor(V8.Net.InternalHandle,System.Boolean)">
            <summary>
            Sets this instance to the same specified handle value.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.UpdateObjectReference">
            <summary>
            Updates the local object reference to point to the manage object that is represented by this handle, and returns
            the object found, or null otherwise.
            <para>The situations that may necessitate calling this method occur if the managed object ID in the underlying
            native proxy object gets updated.  In such (rare and usually specialized) case, this handle will not contain a
            reference to the managed object, and the GC might try to collect it. Internally, this method is always called
            when wrapping a native ProxyHandle pointer with an InternalHandle, which makes sure any related managed object
            also gets properly referenced. The method is also called if 'ObjectID' ever gets updated internally.</para>
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.Set(V8.Net.InternalHandle)">
            <summary>
            Disposes the current handle and sets it to another handle. Before setting, 'KeepAlive()' is called on the given
            handle so both handles can be tracked. Once this handle is set you can treat it like any other object
            reference and copy it around like a normal value (i.e. no need to keep calling this method). A rule of thumb is to 
            either set 'keepAlive' to true when creating a new handle via 'new InternalHandle(...)', or use this method to set
            the initial value.
            <para>Note 1: Under the new handle system, when 'KeepAlive()' is called (default mode for V8NativeObject handles),
            you do not need to call this method anymore. The GC will track it and dispose it when ready.</para>
            <para>Note 2: If the current handle is locked (see IsLocked) then an exception error can occur.</para>
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsLocked">
            <summary>
                Returns true if this handle is directly accessed on a V8NativeObject based object, or the global object.  Such
                handles are disposed under a controlled process that must synchronize across both V8 and V8.Net environments (native
                and managed sides).
            </summary>
            <value> A true or false value. </value>
        </member>
        <member name="P:V8.Net.InternalHandle.CanDispose">
            <summary>
            Returns true if calling 'Dispose()' will release the native side handle immediately on the native side.
            All InternalHandle values not kept alive can be disposed quickly.  The only handle left on a managed object cannot
            be disposed, nor the global object handle, as these will be locked. If false is returned, then there is a managed
            object associated.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle._Finalize(System.Boolean)">
            <summary>
                Releases the unmanaged V8 handle resource. Returns true if released, and false if empty or already released.
            </summary>
            <param name="finalizer"> True if called via the Handle finalizer. </param>
        </member>
        <member name="M:V8.Net.InternalHandle.ForceDispose">
            <summary>
            Forces disposal of the underlying native handle.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.Dispose">
            <summary>
                Disposes of the underlying native handle. If the handle cannot be disposed (perhaps because it is locked), an
                <see cref="T:System.InvalidOperationException"/> error will occur. Optionally you may find 'TryDispose()' more convenient to ignore such
                situations.
                <para>
                If the handle represents a managed V8NativeObject instance, the handle cannot be disposed externally. Managed
                objects will begin a disposal process when there are no more managed references. When this occurs, the native side
                V8 handle is made "weak".  When there are no more references in V8, the V8's GC calls back into the managed side to
                notify that disposal can complete. In all other cases, disposing a handle will succeed.
                </para>
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.TryDispose">
            <summary>
            Same as 'Dispose()', except that any errors are suppressed (i.e. if the handle is locked). 
            If successful (which usually just means this handle was cleared), then 'true' is returned.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsDisposing">
            <summary>
            True if this handle is going through a disposal process on the native side.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsDisposed">
            <summary>
            Returns true if this handle is disposed (no longer in use).  Disposed native proxy handles are kept in a cache for performance reasons.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsCLRDisposed">
            <summary>
            Returns true if the managed side tried to dispose the handle. This sets a bit flag that the handle can be disposed when the native side is ready.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.ID">
            <summary>
            The ID (index) of this handle on both the native and managed sides.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.ValueType">
            <summary>
            The JavaScript type this handle represents.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.Engine">
            <summary>
            A reference to the V8Engine instance that owns this handle.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.ObjectID">
            <summary>
                The ID of the managed object represented by this handle. This ID is expected when handles are passed to
                'V8ManagedObject.GetObject()'.
                <para>If this value is less than 0 then it is a user specified ID tracking value, and as such there is no associated
                'V8NativeObject' object, and the 'Object' property will be null.  This can occur when native objects are created in
                script and returned to the managed side. </para>
            </summary>
            <value> The identifier of the object. </value>
        </member>
        <member name="P:V8.Net.InternalHandle._CurrentObjectID">
            <summary>
            Returns the managed object ID "as is" from the native HandleProxy object.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.Object">
            <summary>
            A reference to the managed object associated with this handle. This property is only valid for object handles, and
            will return null otherwise.
            Because this property reads from the internal engine objects list, which are store as weak references, this property
            can potentially return 'null', even if 'HasObject' returns true.
            <para>Note: Checking 'HasObject' can be initially faster, depending on situation.</para>
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.BoundObject">
            <summary>
            If this handle represents an object instance binder, then this returns the bound object.
            Bound objects are usually custom user objects (non-V8.NET objects) wrapped in ObjectBinder instances.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.CLRTypeID">
            <summary>
            Returns the registered type ID for objects that represent registered CLR types.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.TypeBinder">
            <summary>
            If this handle represents a type binder, then this returns the associated 'TypeBinder' instance.
            <para>Bound types are usually non-V8.NET types that are wrapped and exposed in the JavaScript environment for use with the 'new' operator.</para>
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.HasObject">
            <summary>
            Returns true if this handle is associated with a managed object (checks if ObjectID is valid).
            <para>Note: This can be false even though 'IsObjectType' may be true.
            A handle can represent a native V8 object handle without requiring an associated managed object. In such case,
            'HasObject' returns false.</para>
            <para>Warning: True does not guarantee that 'Object' will not be null.  Objects are referenced by a numerical ID
            and the 'WeakReference' entry may become null under specialized circumstances.  No object reference is actually
            pulled until requested by calling 'GetTrackerHandle()',  'KeepAlive()', or 'UpdateObjectReference()'.
            If any of the previously mentioned methods are called, then this property can be reliable. </para>
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.Value">
            <summary>
                Reading from this property returns either the underlying managed object, or else causes a native call to fetch the
                current V8 value associated with this handle (for primitive types only - for Arrays, see ArrayLength and
                GetProperty(Int32)).
                <para>For objects, this returns the in-script type text as a string - unless this handle represents an object binder,
                in which case this will return the bound object instead.</para>
            </summary>
            <value> The value. </value>
        </member>
        <member name="P:V8.Net.InternalHandle.LastValue">
            <summary>
                Reading from this property returns either the underlying managed object, or else causes a ONE-TIME native call to
                fetch the current V8 value associated with this handle. This can be a bit faster, as subsequent calls return the
                same value.
                <para>Note: If the underlying V8 proxy handle value changes (i.e. properties), you should use the 'Value' property
                instead to make sure any changes are reflected each time.  Only use this property more than once if you're sure the
                target of the V8 handle will not change.</para>
            </summary>
            <value> The last value. </value>
        </member>
        <member name="P:V8.Net.InternalHandle.ArrayLength">
            <summary>
            Returns the array length for handles that represent arrays. For all other types, this returns 0.
            Note: To get the items of the array, use 'GetProperty(#)'.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.ReleaseManagedObject">
            <summary>
            Forces the underlying object, if any, to separate from the handle.  This is done by swapping the managed object with
            a place holder object to keep the ID (index) for the current object alive until the native V8 engine's GC can remove
            any associated handles later.  The released object is returned, or null if there is no object.
            </summary>
            <returns>The object released.</returns>
        </member>
        <member name="P:V8.Net.InternalHandle.IsEmpty">
            <summary>
            Returns true if this handle is empty (that is, equal to 'Handle.Empty'), and false if a valid handle exists. This 
            will also return true if the underlying proxy object ends up in a disposed state.
            <para>An empty state is when a handle is set to 'InternalHandle.Empty' and has no valid native V8 handle assigned.
            This is similar to "undefined"; however, this property will be true if a valid native V8 handle exists that is set to "undefined".</para>
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsUndefined">
            <summary>
            Returns true if this handle is undefined or empty (empty is when this handle is an instance of 'Handle.Empty', or is disposed).
            <para>"Undefined" does not mean "null".  A variable (handle) can be defined and set to "null".</para>
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsNull">
            <summary>
            Returns 'true' if this handle represents a 'null' value (that is, an explicit 'null' value).
            This will return 'false' if 'IsEmpty' or 'IsUndefined' is true.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsObjectType">
            <summary>
            Returns true of the handle represents ANY object type.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsBinder">
            <summary>
            Used internally to quickly determine when an instance represents a binder object type (faster than reflection!).
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.BindingMode">
            <summary>
            Returns the binding mode (Instance, Static, or None) represented by this handle.  The return is 'None' (0) if not applicable.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.As``1">
            <summary>
            Returns the 'Value' property type cast to the expected type (this will not cast from native arrays or objects to a CLR type).
            <para>Warning: No conversion is made between different value types.</para>
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.LastAs``1">
            Returns the 'LastValue' property type cast to the expected type.
            Warning: No conversion is made between different value types.
        </member>
        <member name="P:V8.Net.InternalHandle.AsBoolean">
            <summary>
            Returns the underlying value converted if necessary to a Boolean type.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.AsInt32">
            <summary>
            Returns the underlying value converted if necessary to an Int32 type.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.AsDouble">
            <summary>
            Returns the underlying value converted if necessary to a double type.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.AsString">
            <summary>
            Returns the underlying value converted if necessary to a string type.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.AsDate">
            <summary>
            Returns the underlying value converted if necessary to a DateTime type.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.AsJSProperty">
            <summary>
            Returns this handle as a new JSProperty instance with default property attributes.
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.Description">
            <summary>
            Returns a string describing the handle (mainly for debugging purposes).
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.ToString">
            <summary>
            If this handle represents an object, the 'Description' property value is returned, otherwise the primitive value
            is returned as a string.
            <para>Note: This does not pull the same string as calling 'toString()' in JavaScript.  You have to use the 'Call()' 
            method on this handle to call that function - as you would normally.</para>
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.Equals(System.Object)">
            <summary>
            Checks if the wrapped handle reference is the same as the one compared with. This DOES NOT compare the underlying JavaScript values for equality.
            To test for JavaScript value equality, convert to a desired value-type instead by first casting as needed (i.e. (int)jsv1 == (int)jsv2).
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.IsError">
            <summary>
            Returns true if this handle contains an error message (the string value is the message).
            If you have exception catching in place, you can simply call 'ThrowOnError()' instead.
            <para>Note: This returns false if a script was terminated forcibly. Instead, check the 'WasTerminated' property.</para>
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.ThrowOnError">
            <summary>
            Checks if the handle represents an error, and if so, throws one of the corresponding derived V8Exception exceptions.
            See 'JSValueType' for possible exception states.  You can check the 'IsError' property to see if this handle represents an error.
            <para>Exceptions thrown: V8InternalErrorException, V8CompilerErrorException, V8ExecutionErrorException, and V8Exception (for any general V8-related exceptions).</para>
            </summary>
        </member>
        <member name="P:V8.Net.InternalHandle.WasTerminated">
            <summary>
            Returns true if execution was terminated, usually by calling '{V8Engine}.TerminateExecution()'.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.SetProperty(System.String,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary> Calls the V8 'Set()' function on the underlying native object. Returns true if successful. </summary>
            <exception cref="T:System.ArgumentNullException"> Thrown when one or more required arguments are null. </exception>
            <exception cref="T:System.InvalidOperationException"> Thrown when the requested operation is invalid. </exception>
            <param name="name"> The name. </param>
            <param name="value"> The value. </param>
            <param name="attributes">
                (Optional) Flags that describe the property behavior.  They must be 'OR'd together as needed.
            </param>
            <returns> True if it succeeds, false if it fails. </returns>
            <seealso cref="M:V8.Net.IV8Object.SetProperty(string,InternalHandle,V8PropertyAttributes)"/>
        </member>
        <member name="M:V8.Net.InternalHandle.SetProperty(System.Int32,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary> Calls the V8 'Set()' function on the underlying native object. Returns true if successful. </summary>
            <exception cref="T:System.InvalidOperationException"> Thrown when the requested operation is invalid. </exception>
            <param name="index"> Zero-based index to set. </param>
            <param name="value"> The value to set. </param>
            <param name="attributes">
                (Optional) Flags that describe the property behavior.  They must be 'OR'd together as needed.
                <para>Warning: V8 does not support setting attributes using numerical indexes.  If you set an attribute, the given
                value is converted to a string, and a named property setter will be used instead. </para>
            </param>
            <returns> True if it succeeds, false if it fails. </returns>
            <seealso cref="M:V8.Net.IV8Object.SetProperty(Int32,InternalHandle,V8PropertyAttributes)"/>
        </member>
        <member name="M:V8.Net.InternalHandle.SetProperty(System.String,System.Object,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Sets a property to a given object. If the object is not V8.NET related, then the system will attempt to bind the instance and all public members to
            the specified property name.
            Returns true if successful.
            </summary>
            <param name="name">The property name. If 'null', then the name of the object type is assumed.</param>
            <param name="obj">Some value or object instance. 'Engine.CreateValue()' will be used to convert value types, unless the object is already a handle, in which case it is set directly.</param>
            <param name="className">A custom in-script function name for the specified object type, or 'null' to use either the type name as is (the default) or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">For object instances, if true, then object reference members are included, otherwise only the object itself is bound and returned.
            For security reasons, public members that point to object instances will be ignored. This must be true to included those as well, effectively allowing
            in-script traversal of the object reference tree (so make sure this doesn't expose sensitive methods/properties/fields).</param>
            <param name="memberSecurity">For object instances, these are default flags that describe JavaScript properties for all object instance members that
            don't have any 'ScriptMember' attribute.  The flags should be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.InternalHandle.SetProperty(System.Int32,System.Object,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Sets a property to a given object. If the object is not V8.NET related, then the system will attempt to bind the instance and all public members to
            the specified property name.
            Returns true if successful.
            </summary>
            <param name="index"> Zero-based index to set. </param>
            <param name="obj">Some value or object instance. 'Engine.CreateValue()' will be used to convert value types, unless the object is already a handle, in which case it is set directly.</param>
            <param name="className">A custom in-script function name for the specified object type, or 'null' to use either the type name as is (the default) or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">For object instances, if true, then object reference members are included, otherwise only the object itself is bound and returned.
            For security reasons, public members that point to object instances will be ignored. This must be true to included those as well, effectively allowing
            in-script traversal of the object reference tree (so make sure this doesn't expose sensitive methods/properties/fields).</param>
            <param name="memberSecurity">For object instances, these are default flags that describe JavaScript properties for all object instance members that
            don't have any 'ScriptMember' attribute.  The flags should be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.InternalHandle.SetProperty(System.Type,V8.Net.V8PropertyAttributes,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Binds a 'V8Function' object to the specified type and associates the type name (or custom script name) with the underlying object.
            Returns true if successful.
            </summary>
            <param name="type">The type to wrap.</param>
            <param name="propertyAttributes">Flags that describe the property behavior.  They must be 'OR'd together as needed.</param>
            <param name="className">A custom in-script function name for the specified type, or 'null' to use either the type name as is (the default) or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">For object types, if true, then object reference members are included, otherwise only the object itself is bound and returned.
            For security reasons, public members that point to object instances will be ignored. This must be true to included those as well, effectively allowing
            in-script traversal of the object reference tree (so make sure this doesn't expose sensitive methods/properties/fields).</param>
            <param name="memberSecurity">For object instances, these are default flags that describe JavaScript properties for all object instance members that
            don't have any 'ScriptMember' attribute.  The flags should be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.InternalHandle.GetProperty(System.String)">
            <summary>
            Calls the V8 'Get()' function on the underlying native object.
            If the property doesn't exist, the 'IsUndefined' property will be true.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.GetProperty(System.Int32)">
            <summary>
            Calls the V8 'Get()' function on the underlying native object.
            If the property doesn't exist, the 'IsUndefined' property will be true.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.DeleteProperty(System.String)">
            <summary>
            Calls the V8 'Delete()' function on the underlying native object.
            Returns true if the property was deleted.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.DeleteProperty(System.Int32)">
            <summary>
            Calls the V8 'Delete()' function on the underlying native object.
            Returns true if the property was deleted.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.SetAccessor(System.String,V8.Net.GetterAccessor,V8.Net.SetterAccessor,V8.Net.V8PropertyAttributes,V8.Net.V8AccessControl)">
            <summary>
                Calls the V8 'SetAccessor()' function on the underlying native object to create a property that is controlled by
                "getter" and "setter" callbacks.
                <para>WARNING: If you try to set managed accessors on a native-ONLY object (as in, this handle does not yet have a
                managed-side object associated with it) then
                <see cref="M:V8.Net.V8Engine.CreateObject(V8.Net.InternalHandle,System.Boolean)"/> will be called to create a wrapper object so the
                accessor delegates will not get garbage collected, causing errors. You can optionally take control of this yourself
                and call one of the 'CreateObject()' methods on <see cref="T:V8.Net.V8Engine"/>.</para>
            </summary>
            <exception cref="T:System.ArgumentNullException"> Thrown when one or more required arguments are null. </exception>
            <exception cref="T:System.InvalidOperationException"> Thrown when the requested operation is invalid. </exception>
            <param name="name"> The property name. </param>
            <param name="getter">
                The property getter delegate that returns a value when the property is accessed within JavaScript.
            </param>
            <param name="setter">
                The property setter delegate that sets AND returns a value when the property is accessed within JavaScript.
            </param>
            <param name="attributes"> (Optional) The attributes to assign to the property. </param>
            <param name="access"> (Optional) The access security on the property. </param>
            <seealso cref="M:V8.Net.IV8Object.SetAccessor(string,GetterAccessor,SetterAccessor,V8PropertyAttributes,V8AccessControl)"/>
        </member>
        <member name="M:V8.Net.InternalHandle.GetPropertyNames">
            <summary>
            Returns a list of all property names for this object (including all objects in the prototype chain).
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.GetOwnPropertyNames">
            <summary>
            Returns a list of all property names for this object (excluding the prototype chain).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:V8.Net.InternalHandle.GetPropertyAttributes(System.String)" -->
        <member name="M:V8.Net.InternalHandle.Call(System.String,V8.Net.InternalHandle,V8.Net.InternalHandle[])">
            <summary>
            Calls the specified function property on the underlying object.
            The '_this' parameter is the "this" reference within the function when called.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.StaticCall(System.String,V8.Net.InternalHandle[])">
            <summary>
            Calls the specified function property on the underlying object.
            The 'this' property will not be specified, which will default to the global scope as expected.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.Call(V8.Net.InternalHandle,V8.Net.InternalHandle[])">
            <summary>
            Calls the underlying object as a function.
            The '_this' parameter is the "this" reference within the function when called.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.StaticCall(V8.Net.InternalHandle[])">
            <summary>
            Calls the underlying object as a function.
            The 'this' property will not be specified, which will default to the global scope as expected.
            </summary>
        </member>
        <member name="M:V8.Net.InternalHandle.GetPrototype">
            <summary>
            The prototype of the object (every JavaScript object implicitly has a prototype).
            <para>Note: As with any InternalHandle returned, you are responsible to dispose it.  It is recommended to type cast
            this to an ObjectHandle before use.</para>
            </summary>
        </member>
        <member name="T:V8.Net.GetterAccessor">
            <summary>
            Intercepts JavaScript access for properties on the associated JavaScript object for retrieving a value.
            <para>To allow the V8 engine to perform the default get action, return "Handle.Empty".</para>
            </summary>
        </member>
        <member name="T:V8.Net.SetterAccessor">
            <summary>
            Intercepts JavaScript access for properties on the associated JavaScript object for setting values.
            <para>To allow the V8 engine to perform the default set action, return "Handle.Empty".</para>
            </summary>
        </member>
        <member name="F:V8.Net.BindingMode.None">
            <summary>
            The V8NativeObject is not a binding object.
            </summary>
        </member>
        <member name="F:V8.Net.BindingMode.Instance">
            <summary>
            The V8NativeObject is a binding object for instances (i.e. ObjectBinder).
            </summary>
        </member>
        <member name="F:V8.Net.BindingMode.Static">
            <summary>
            The V8NativeObject is not a binding object for types  (i.e. V8Function).
            </summary>
        </member>
        <member name="T:V8.Net.TypeBinderFunction">
            <summary>
            Represent a TypeBinder JavaScript function (for static properties, and creating new objects in script).
            </summary>
        </member>
        <member name="T:V8.Net.TypeLibrary`1">
            <summary>
            Keeps track of object references based on an array of one or more related types. The reference is stored with the last type entry.
            The object references are stored based on a tree of nested types for fast dictionary-tree-style lookup.
            Currently, this class is used in the type binder to cache references to MemberInfo objects based on generic type parameters.
            </summary>
        </member>
        <member name="M:V8.Net.TypeLibrary`1.Get(System.Boolean,System.Type[])">
            <summary> Gets the object of type <typeparamref name="T"/> from the type tree based on given types. </summary>
            <param name="strict">
                True to find exact type matches. If false is past in, and a type can't be found explicitly, then the best match is
                found based on assignability.
            </param>
            <param name="types"> A variable-length parameters list containing types. </param>
            <returns> Returns the type 'T' instance. </returns>
        </member>
        <member name="M:V8.Net.TypeLibrary`1.Exists(System.Boolean,System.Type[])">
            <summary> Determine if an object exists using the given types. </summary>
            <param name="strict">
                True to find exact type matches. If false is past in, and a type can't be found explicitly, then the best match is
                found based on assignability.
            </param>
            <param name="types"> A variable-length parameters list containing types. </param>
            <returns> True if it succeeds, false if it fails. </returns>
        </member>
        <member name="T:V8.Net.ArgInfo">
            <summary>
            Wraps a script value with strong CLR type information for use with generics and method invocation.
            <para>
            This struct represents an argument passed from script to V8.NET binding logic. If the argument represents type information, it is extracted.
            In either case, 'Value' will be the requested strong-typed value, or the default value, whichever is detected first (in that order).
            This can be used to pass arguments to methods, where the value is converted to a specific type if necessary.
            </para>
            <para>Warning: The struct only extracts information, converting the script argument if necessary, and does not own the 'ArgInfoSource' handle.
            As such, the caller is still responsible to release it.</para>
            </summary>
        </member>
        <member name="P:V8.Net.ArgInfo.IsValid">
            <summary>
            Returns true if this ArgInfo value has valid type information.  This will be false for empty instances.
            </summary>
        </member>
        <member name="F:V8.Net.ArgInfo.HasValue">
            <summary>
            Returns true if a valid value exists.  If false is returned, this usually means this is a type-only ArgInfo object.
            </summary>
        </member>
        <member name="P:V8.Net.ArgInfo.IsSourceFromArgInfoObject">
            <summary>
            Returns true if the information was taken from a native ArgInfo object.
            </summary>
        </member>
        <member name="P:V8.Net.ArgInfo.ValueOrDefault">
            <summary>
            Returns either the underlying argument value (in converted form), or the default value, whichever is detected first (in that order).
            This can be used to pass arguments to methods, where a specific CLR type is required.
            </summary>
        </member>
        <member name="M:V8.Net.ArgInfo.GetArguments(V8.Net.InternalHandle[],System.UInt32,System.Reflection.ParameterInfo[])">
            <summary>
            Returns an array of ArgInfo values for the given handles.
            </summary>
        </member>
        <member name="M:V8.Net.ArgInfo.GetTypes(V8.Net.InternalHandle[],System.UInt32,System.Type[])">
            <summary>
            Returns an array of ArgInfo values for the expected types.
            </summary>
        </member>
        <member name="M:V8.Net.ArgInfo.GetSystemTypes(System.Collections.Generic.IEnumerable{V8.Net.ArgInfo})">
            <summary>
            Returns an array of ArgInfo values for the expected types.
            </summary>
        </member>
        <member name="M:V8.Net.ArgInfo.GetHandles(V8.Net.ArgInfo[])">
            <summary>
            Extracts and returns an array of all handles from the specified arguments.
            </summary>
            <param name="argInfoArgs"></param>
            <returns></returns>
        </member>
        <member name="T:V8.Net.TypeBinder">
            <summary>
            A V8.NET binder for CLR types.
            </summary>
        </member>
        <member name="F:V8.Net.TypeBinder.Engine">
            <summary>
            The engine that will own the 'ObjectTemplate' instance.
            </summary>
        </member>
        <member name="F:V8.Net.TypeBinder.BaseTypeBinder">
            <summary>
            A reference to the type binder for the immediate base type inherited by the bound type.
            </summary>
        </member>
        <member name="F:V8.Net.TypeBinder.InstanceTemplate">
            <summary>
            Represents a V8 template object used for generating native V8 objects which will correspond to the binding for 
            instances of the underlying type.
            </summary>
        </member>
        <member name="F:V8.Net.TypeBinder.TypeTemplate">
            <summary>
            Represents a V8 template object used for generating native V8 function objects which will correspond to the binding 
            for the underlying type (for creating new instances within script).
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder.TypeFunction">
            <summary>
            The function used to represent this bound type in script.
            </summary>
        </member>
        <member name="F:V8.Net.TypeBinder.BoundType">
            <summary>
            The type represented by this type binder.
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder.TypeID">
            <summary>
            A unique internal ID used to quickly identify the type for best performance.
            </summary>
        </member>
        <member name="F:V8.Net.TypeBinder.ClassName">
            <summary>
            The name that will be displayed when invoking 'Object.valueOf()' in JavaScript on function objects which represent this type.
            This is also the name that will be used for the property created from this type binder.
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder.Recursive">
            <summary>
            If true, then nested object references are included, otherwise they are ignored.  By default, the references are ignored for security reasons.
            <param>When an object is bound, only the object instance itself is bound (and not any reference members).</param>
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder.DefaultMemberSecurity">
            <summary>
            Default member attributes for members that don't have the 'ScriptMember' attribute.
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder.Indexer">
            <summary>
            The indexer for this type, if applicable, otherwise this is null.
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder.ScriptObjectAttribute">
            <summary>
            The ScriptObject attribute if one exists for the underlying type, otherwise this is null.
            </summary>
        </member>
        <member name="T:V8.Net.TypeBinder._MemberDetails">
            <summary>
            Holds details for each member on a type when binding objects.
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder._MemberDetails.MemberTypeLibraries">
            <summary>
            Enumerates all the type libraries for this member detail and any base member details.
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder._MemberDetails.Members">
            <summary>
            Enumerates all the type libraries for this member detail and any base member details,
            and returns each underlying MemberInfo reference.
            </summary>
        </member>
        <member name="P:V8.Net.TypeBinder._MemberDetails.MethodMembers">
            <summary>
            Enumerates all the type libraries for this member detail and any base member details,
            and returns each underlying MethodInfo reference.
            </summary>
        </member>
        <member name="M:V8.Net.TypeBinder._MemberDetails.FindMemberByTypes(System.Boolean,System.Type[])">
            <summary>
                Given a list of types, returns the matching MemberInfo reference, or 'null' if not found. This is used mainly with
                member details instances representing overloaded method members.
            </summary>
            <param name="strict">
                True to find exact type matches. If false is past in, and a type can't be found explicitly, then the best match is
                found based on assignability.
            </param>
            <param name="types"> . </param>
            <returns> The found member by types. </returns>
        </member>
        <member name="P:V8.Net.TypeBinder.BaseBinders">
            <summary>
            Enumerates all type binders in the inheritance hierarchy.
            </summary>
        </member>
        <member name="M:V8.Net.TypeBinder._CreateMemberDetails(System.String,System.Nullable{V8.Net.ScriptMemberSecurity},System.Reflection.MemberInfo,System.Func{System.String,V8.Net.TypeBinder._MemberDetails},System.Action{V8.Net.TypeBinder._MemberDetails})">
            <summary>
            Used to help update a '_MemberDetails' dictionary with the supplied member information via supplied callbacks.
            The members are tracked by name (via the 'getExisting()' callback), and as such, only a single '_MemberDetails'
            instance should exist per name.  Other members are added as overloads to the instance returned from 'getExisting()',
            if any.
            </summary>
            <param name="memberName">The name of the member to create the details for.</param>
            <param name="memberSecurity">The member security to apply.</param>
            <param name="memberInfo">The type's member information details.</param>
            <param name="getExisting">A callback to check if there's an existing member by the same name.</param>
            <param name="set">A callback for when no member exists and needs to be added (i.e. no existing member details were updated).</param>
            <returns>The resulting '_MemberDetails' instance, which may be an already existing one.</returns>
        </member>
        <member name="M:V8.Net.TypeBinder._GetBindingForDataMember(V8.Net.TypeBinder._MemberDetails,V8.Net.NativeGetterAccessor@,V8.Net.NativeSetterAccessor@)">
            <summary> Binds a getter and setter to read and/or write to the specified data member (field or property only). </summary>
            <param name="memberDetails"> Member details which to get getter and setter binding for. </param>
            <param name="getter"> [out] Returns the getter delegate to use for a native callback. </param>
            <param name="setter"> [out] Returns the setter delegate to use for a native callback. </param>
            <returns> True if it succeeds, false if it fails. </returns>
        </member>
        <member name="M:V8.Net.TypeBinder._GetBindingForProperty(V8.Net.TypeBinder._MemberDetails,V8.Net.NativeGetterAccessor@,V8.Net.NativeSetterAccessor@)">
            <summary>
            Binds a getter and setter to read and/or write to the specified data member.
            </summary>
            <param name="memberDetails">Member details which to get getter and setter binding for.</param>
            <param name="getter">Returns the getter delegate to use for a native callback.</param>
            <param name="setter">Returns the setter delegate to use for a native callback.</param>
        </member>
        <member name="M:V8.Net.TypeBinder._GetBindingForMethod(V8.Net.TypeBinder._MemberDetails,V8.Net.V8Function@,System.String)">
            <summary>
            Binds a specific or named method of the specified object to a 'V8Function' callback wrapper.
            The returned function can be used in setting native V8 object properties to function values.
            </summary>
            <param name="memberDetails">A reference to the member details for the given function representing the underlying type.</param>
            <param name="func">The 'V8Function' wrapper for specified method. This function can be used with 'new' in JS to create a new instance of the CLR type.</param>
            <param name="methodName">An optional name to return when 'valueOf()' is called on a JS object (this defaults to the method's name [i.e. 'memberDetails.MemberName']).</param>
        </member>
        <member name="M:V8.Net.TypeBinder._BindTypeMembers">
            <summary>
            Binds the constructor and all static members on the underlying type.
            </summary>
        </member>
        <member name="M:V8.Net.TypeBinder.CreateObject``2(``1,System.Boolean)">
            <summary>
            Returns a new 'ObjectBinder' based instance that is associated with the specified object instance.
            It's an error to pass an object instance that is not of the same underlying type as this type binder.
            </summary>
            <param name="obj">An object instance for the object binder (required).</param>
            <param name="initializeBinder">If true (default) then then 'IV8NativeObject.Initialize()' is called on the created object before returning.</param>
            <returns>A new 'ObjectBinder' instance you can use when setting properties to the specified object instance.</returns>
        </member>
        <member name="M:V8.Net.TypeBinder.CreateObject(System.Object,System.Boolean)">
            <summary>
            Returns a new 'ObjectBinder' based instance that is associated with the specified object instance.
            It's an error to pass an object instance that is not of the same underlying type as this type binder.
            </summary>
            <param name="initializeBinder">If true (default) then 'IV8NativeObject.Initialize()' is called on the created object before returning.</param>
            <returns>A new 'ObjectBinder' instance you can use when setting properties to the specified object instance.</returns>
        </member>
        <member name="M:V8.Net.TypeBinder.ChangeMemberSecurity(System.Reflection.MemberInfo,V8.Net.ScriptMemberSecurity)">
            <summary>
            Changes the security of a specific member for the underlying type represented by this TypeBinder instance.
            </summary>
            <param name="member">A specific MemberInfo instance.  If this is not found/supported on the local type, an exception will be thrown.</param>
            <param name="memberSecurity">The new security to apply.</param>
        </member>
        <member name="M:V8.Net.TypeBinder.ChangeMemberSecurity(System.String,V8.Net.ScriptMemberSecurity)">
            <summary>
            Changes the security of a specific member for the underlying type represented by this TypeBinder instance.
            </summary>
            <param name="memberName">A specific member name.  If this is not found/supported on the local type, or the name has too many matches, an exception will be thrown.
            <para>Note: The name you enter here is the in-script name, including any "${type #}" suffixes for generic types (for example, "Join$1", where '1' is the
            number of expected generic types).  If a member has overloads, the security attribute will apply to all of them.</para></param>
            <param name="security">The new security to apply.</param>
        </member>
        <member name="T:V8.Net.ObjectBinder">
            <summary>
            'ObjectBinder' instances represent JavaScript object properties that are bound to CLR objects or types.
            </summary>
        </member>
        <member name="P:V8.Net.ObjectBinder.Object">
            <summary>
                Gets or sets the CLR object that is associated with this binding. You can dynamically replace objects, but only of
                the same type once set the first time.
            </summary>
            <exception cref="T:System.InvalidOperationException">
                Thrown if the object is set again with an instance of a different type.
            </exception>
            <value> The object associated with this binding. </value>
        </member>
        <member name="P:V8.Net.ObjectBinder.ObjectType">
            <summary>
                Gets or sets the type of the object that this binder will work with. Once this is set it cannot be changed.
            </summary>
            <exception cref="T:System.InvalidOperationException">
                Thrown if the object type is set again with a different type.
            </exception>
            <value> The type of the object expected for this binder. </value>
        </member>
        <member name="P:V8.Net.ObjectBinder.TypeBinder">
            <summary>
                Gets or sets the type binder that is automatically set when <see cref="P:V8.Net.ObjectBinder.Object"/> or <see cref="P:V8.Net.ObjectBinder.ObjectType"/> is set.
                The TypeBinder reference holds all the cached reflection details needed to read the associated CLR object instance.
                As the JavaScript code accesses new properties and types not yet bound, they get bound automatically when accessed.
                This prevents the need to bind everything at once!
            </summary>
            <value> The type binder associated with this binder instance. </value>
        </member>
        <member name="T:V8.Net.IV8Disposable">
            <summary>
            Applied to V8 related objects to better coordinated disposing native resources on the native V8 engine side via the worker thread.
            <para>'IV8Disposable' objects are added to an internal "disposal" queue when they are finalized.  This is done because
            some tasks, such as disposing handles, cannot be performed in a finalizer method.  Because of this, the event is
            deferred to a worker process queue to continue processing as soon as possible.</para>
            </summary>
        </member>
        <member name="P:V8.Net.IV8Disposable.Engine">
            <summary>
            The V8.Net engine that his disposable object belongs to.
            </summary>
        </member>
        <member name="P:V8.Net.IV8Disposable.CanDispose">
            <summary>
            If this is true, the object is ok to be disposed.
            </summary>
        </member>
        <member name="T:V8.Net.RootableWeakReference">
            <summary> Allows overriding the weak reference by rooting the target object to this entry. </summary>
        </member>
        <member name="F:V8.Net.RootableWeakReference.RootedReference">
            <summary> Allows overriding the weak reference by rooting the target object to this entry. </summary>
        </member>
        <member name="T:V8.Net.IV8NativeObject">
            <summary>
            An interface for objects wrapped by V8NativeObject instances.
            <para>These methods are called in proxy to the V8NativeObject's related methods ('Initialize(...)' and 'Dispose(...)').</para>
            The arguments passed to 'Initialize(...)' ('isConstructCall' and 'args') are the responsibility of the developer - except for the binder, which will
            pass in the values as expected.
            </summary>
        </member>
        <member name="M:V8.Net.IV8NativeObject.Initialize(V8.Net.V8NativeObject,System.Boolean,V8.Net.InternalHandle[])">
            <summary>
            Called immediately after creating an object instance and setting the V8Engine property.
            Derived objects should override this for construction instead of using the constructor, and be sure to call back to this base method just before exiting (not at the beginning).
            In the constructor, the object only exists as an empty shell.
            It's ok to setup non-v8 values in constructors, but be careful not to trigger any calls into the V8Engine itself.
            <para>Note: Because this method is virtual, it does not guarantee that 'IsInitialized' will be considered.  Implementations should check against
            the 'IsInitilized' property.</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8NativeObject.OnDispose">
            <summary>
            Called when there are no more references on either the managed or native side.  In such case the object is ready to
            be deleted from the V8.NET system.
            <para>You should never call this from code directly unless you need to force the release of native resources associated
            with a custom implementation (and if so, a custom internal flag should be kept indicating whether or not the
            resources have been disposed to be safe).</para>
            <para>You should always override/implement this if you need to dispose of any native resources in custom implementations.</para>
            <para>DO NOT rely on the destructor (finalizer) - some objects may survive it (due to references on the native V8 side).</para>
            <para>Note: This can be triggered via the worker thread.</para>
            </summary>
        </member>
        <member name="T:V8.Net.V8NativeObject">
            <summary>
            Represents a basic JavaScript object. This class wraps V8 functionality for operations required on any native V8 object (including managed ones).
            <para>This class implements 'DynamicObject' to make setting properties a bit easier.</para>
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.Engine">
            <summary>
            A reference to the V8Engine instance that owns this object.
            The default implementation for <see cref="T:V8.Net.V8NativeObject"/> is to cache and return 'base.Engine', since it inherits from 'Handle'.
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.Getter">
            <summary>
                This is updated to hold a reference to the property value getter callback when
                <see cref="M:V8.Net.V8NativeObject.SetAccessor(System.String,V8.Net.GetterAccessor,V8.Net.SetterAccessor,V8.Net.V8PropertyAttributes,V8.Net.V8AccessControl)"/> is called.
                Without a rooted reference the delegate will get garbage collected causing callbacks from the native side will fail.
            </summary>
            <value> The getter. </value>
        </member>
        <member name="P:V8.Net.V8NativeObject.Setter">
            <summary>
                This is updated to hold a reference to the property value setter callback when
                <see cref="M:V8.Net.V8NativeObject.SetAccessor(System.String,V8.Net.GetterAccessor,V8.Net.SetterAccessor,V8.Net.V8PropertyAttributes,V8.Net.V8AccessControl)"/> is called.
                Without a rooted reference the delegate will get garbage collected causing callbacks from the native side will fail.
            </summary>
            <value> The getter. </value>
        </member>
        <member name="P:V8.Net.V8NativeObject.Template">
            <summary>
            The V8.NET ObjectTemplate or FunctionTemplate instance associated with this object, if any, or null if this object was not created using a V8.NET template.
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.ID">
            <summary>
            The V8.NET managed object ID used to track this object instance on both the native and managed sides.
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.Proxy">
            <summary>
            Another object of the same interface to direct actions to (such as 'Initialize()').
            If the generic type 'V8NativeObject&lt;T>' is used, then this is set to an instance of "T", otherwise this is set to "this" instance.
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.IsInitilized">
            <summary>
            True if this object was initialized and is ready for use.
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.InternalHandle">
            <summary>
            A reference to the managed object handle that wraps the native V8 handle for this managed object.
            The default implementation for 'V8NativeObject' is to return itself, since it inherits from 'Handle'.
            Setting this property will call the inherited 'Set()' method to replace the handle associated with this object instance (this should never be done on
            objects created from templates ('V8ManagedObject' objects), otherwise callbacks from JavaScript to the managed side will not act as expected, if at all).
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.AsDynamic">
            <summary>
            Returns a "dynamic" reference to this object (which is simply the handle instance, which has dynamic support).
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.Prototype">
            <summary>
            The prototype of the object (every JavaScript object implicitly has a prototype).
            </summary>
        </member>
        <member name="P:V8.Net.V8NativeObject.BindingType">
            <summary>
            Used internally to quickly determine when an instance represents a binder object type, or static type binder function (faster than reflection!).
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.Initialize(System.Boolean,V8.Net.InternalHandle[])">
            <summary>
            Called immediately after creating an object instance and setting the V8Engine property.
            Derived objects should override this for construction instead of using the constructor, and be sure to call back to this base method just before exiting (not at the beginning).
            In the constructor, the object only exists as an empty shell.
            It's ok to setup non-v8 values in constructors, but be careful not to trigger any calls into the V8Engine itself.
            <para>Note: Because this method is virtual, it does not guarantee that 'IsInitialized' will be considered.  Implementations should check against
            the 'IsInitilized' property.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.Initialize(V8.Net.V8NativeObject,System.Boolean,V8.Net.InternalHandle[])">
            <summary>
            (Exists only to support the 'IV8NativeInterface' interface and should not be called directly - call 'Initialize(isConstructCall, args)' instead.)
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.OnDispose">
            <summary>
            Called when there are no more references on either the managed or native side.  In such case the object is ready to
            be deleted from the V8.NET system.
            <para>You should never call this from code directly unless you need to force the release of native resources associated
            with a custom implementation (and if so, a custom internal flag should be kept indicating whether or not the
            resources have been disposed to be safe).</para>
            <para>You should always override/implement this if you need to dispose of any native resources in custom implementations.</para>
            <para>DO NOT rely on the destructor (finalizer) - some objects may survive it (due to references on the native V8 side).</para>
            <para>Note: This can be triggered via the worker thread.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject._Dispose">
            <summary>
                Returns true if disposed, and false if already disposed.
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.SetProperty(System.String,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary>
            Calls the V8 'Set()' function on the underlying native object.
            Returns true if successful.
            </summary>
            <param name="attributes">Flags that describe the property behavior.  They must be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.V8NativeObject.SetProperty(System.Int32,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary>
            Calls the V8 'Set()' function on the underlying native object.
            Returns true if successful.
            </summary>
            <param name="index"> Zero-based index to set. </param>
            <param name="value"> The value to set. </param>
            <param name="attributes">
                (Optional) Flags that describe the property behavior.  They must be 'OR'd together as needed.
                <para>Warning: V8 does not support setting attributes using numerical indexes.  If you set an attribute, the given
                value is converted to a string, and a named property setter will be used instead. </para>
            </param>
        </member>
        <member name="M:V8.Net.V8NativeObject.SetProperty(System.String,System.Object,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Sets a property to a given object. If the object is not V8.NET related, then the system will attempt to bind the instance and all public members to
            the specified property name.
            Returns true if successful.
            </summary>
            <param name="name">The property name.</param>
            <param name="obj">Some value or object instance. 'Engine.CreateValue()' will be used to convert value types.</param>
            <param name="className">A custom in-script function name for the specified object type, or 'null' to use either the type name as is (the default) or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">For object instances, if true, then object reference members are included, otherwise only the object itself is bound and returned.
            For security reasons, public members that point to object instances will be ignored. This must be true to included those as well, effectively allowing
            in-script traversal of the object reference tree (so make sure this doesn't expose sensitive methods/properties/fields).</param>
            <param name="memberSecurity">For object instances, these are default flags that describe JavaScript properties for all object instance members that
            don't have any 'ScriptMember' attribute.  The flags should be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.V8NativeObject.SetProperty(System.Type,V8.Net.V8PropertyAttributes,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Binds a 'V8Function' object to the specified type and associates the type name (or custom script name) with the underlying object.
            Returns true if successful.
            </summary>
            <param name="type">The type to wrap.</param>
            <param name="propertyAttributes">Flags that describe the property behavior.  They must be 'OR'd together as needed.</param>
            <param name="className">A custom in-script function name for the specified type, or 'null' to use either the type name as is (the default) or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">For object types, if true, then object reference members are included, otherwise only the object itself is bound and returned.
            For security reasons, public members that point to object instances will be ignored. This must be true to included those as well, effectively allowing
            in-script traversal of the object reference tree (so make sure this doesn't expose sensitive methods/properties/fields).</param>
            <param name="memberSecurity">For object instances, these are default flags that describe JavaScript properties for all object instance members that
            don't have any 'ScriptMember' attribute.  The flags should be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.V8NativeObject.GetProperty(System.String)">
            <summary>
            Calls the V8 'Get()' function on the underlying native object.
            If the property doesn't exist, the 'IsUndefined' property will be true.
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.GetProperty(System.Int32)">
            <summary>
            Calls the V8 'Get()' function on the underlying native object.
            If the property doesn't exist, the 'IsUndefined' property will be true.
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.DeleteProperty(System.String)">
            <summary>
            Calls the V8 'Delete()' function on the underlying native object.
            Returns true if the property was deleted.
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.DeleteProperty(System.Int32)">
            <summary>
            Calls the V8 'Delete()' function on the underlying native object.
            Returns true if the property was deleted.
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.SetAccessor(System.String,V8.Net.GetterAccessor,V8.Net.SetterAccessor,V8.Net.V8PropertyAttributes,V8.Net.V8AccessControl)">
            <summary>
                Calls the V8 'SetAccessor()' function on the underlying native object to create a property that is controlled by
                "getter" and "setter" callbacks.
                <para>WARNING: If you try to set managed accessors on a native-ONLY object (as in, this handle does not yet have a
                managed-side object associated with it) then
                <see cref="M:V8.Net.V8Engine.CreateObject(V8.Net.InternalHandle,System.Boolean)"/> will be called to create a wrapper object so the
                accessor delegates will not get garbage collected, causing errors. You can optionally take control of this yourself
                and call one of the 'CreateObject()' methods on <see cref="T:V8.Net.V8Engine"/>.</para>
            </summary>
            <param name="name"> The property name. </param>
            <param name="getter">
                The property getter delegate that returns a value when the property is accessed within JavaScript.
            </param>
            <param name="setter">
                The property setter delegate that sets AND returns a value when the property is accessed within JavaScript.
            </param>
            <param name="attributes"> (Optional) The attributes to assign to the property. </param>
            <param name="access"> (Optional) The access security on the property. </param>
            <seealso cref="M:V8.Net.IV8Object.SetAccessor(string,GetterAccessor,SetterAccessor,V8PropertyAttributes,V8AccessControl)"/>
        </member>
        <member name="M:V8.Net.V8NativeObject.GetPropertyNames">
            <summary>
            Returns a list of all property names for this object (including all objects in the prototype chain).
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.GetOwnPropertyNames">
            <summary>
            Returns a list of all property names for this object (excluding the prototype chain).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:V8.Net.V8NativeObject.GetPropertyAttributes(System.String)" -->
        <member name="M:V8.Net.V8NativeObject.Call(System.String,V8.Net.InternalHandle,V8.Net.InternalHandle[])">
            <summary>
            Calls an object property with a given name on a specified object as a function and returns the result.
            The '_this' property is the "this" object within the function when called.
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.StaticCall(System.String,V8.Net.InternalHandle[])">
            <summary>
            Calls an object property with a given name on a specified object as a function and returns the result.
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.Call(V8.Net.InternalHandle,V8.Net.InternalHandle[])">
            <summary>
            Calls the underlying object as a function.
            The '_this' parameter is the "this" reference within the function when called.
            </summary>
        </member>
        <member name="M:V8.Net.V8NativeObject.StaticCall(V8.Net.InternalHandle[])">
            <summary>
            Calls the underlying object as a function.
            The 'this' property will not be specified, which will default to the global scope as expected.
            </summary>
        </member>
        <member name="T:V8.Net.V8NativeObject`1">
            <summary>
            This generic version of 'V8NativeObject' allows injecting your own class by implementing the 'IV8NativeObject' interface.
            </summary>
            <typeparam name="T">Your own class, which implements the 'IV8NativeObject' interface.  Don't use the generic version if you are able to inherit from 'V8NativeObject' instead.</typeparam>
        </member>
        <member name="T:V8.Net.IV8Function">
            <summary>
            The 'V8Function' inherits from V8NativeObject, which implements 'DynamicObject' for you, but if dynamic objects are not required,
            feel free to implement the 'IV8Function' interface for your own classes instead.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:V8.Net.IV8Function.FunctionTemplate" -->
        <member name="P:V8.Net.IV8Function.Callback">
            <summary>
            A managed callback reference, which is called when the javaScript function is called.
            You can dynamically update this at any time, or even set it to null.
            </summary>
        </member>
        <member name="M:V8.Net.IV8Function.StaticCall(V8.Net.InternalHandle[])">
            <summary>
            Calls the native side to invoke the function associated with this managed function wrapper.
            <para>Note: This simply calls 'base.Call()' without a function name.</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8Function.Call(V8.Net.InternalHandle,V8.Net.InternalHandle[])">
            <summary>
            Calls the native side to invoke the function associated with this managed function wrapper.
            The '_this' property is the "this" object within the function when called.
            <para>Note: This simply calls 'base.Call()' without a function name.</para>
            </summary>
        </member>
        <member name="T:V8.Net.V8Function">
            <summary>
            Represents a basic JavaScript function object.  By default, this object is used for the global environment.
            </summary>
        </member>
        <member name="M:V8.Net.V8Function.StaticCall(V8.Net.InternalHandle[])">
            <summary>
            Calls the native side to invoke the function associated with this managed function wrapper.
            <para>Note: This method simply calls 'Handle.Call()' without a function name.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Function.Call(V8.Net.InternalHandle,V8.Net.InternalHandle[])">
            <summary>
            Calls the native side to invoke the function associated with this managed function wrapper.
            The '_this' property is the "this" object within the function when called.
            <para>Note: This method simply calls 'Handle.Call()' without a function name.</para>
            </summary>
        </member>
        <member name="M:V8.Net.V8Function.Call(System.String,V8.Net.InternalHandle,V8.Net.InternalHandle[])">
            <summary>
            If the function object has a function property in itself (usually considered a static property in theory), you can use this to invoke it.
            </summary>
        </member>
        <member name="T:V8.Net.V8Function`1">
            <summary>
            This generic version of 'V8ManagedObject' allows injecting your own class by implementing the 'IV8ManagedObject' interface.
            </summary>
            <typeparam name="T">Your own class, which implements the 'IV8ManagedObject' interface.  Don't use the generic version if you are able to inherit from 'V8ManagedObject' instead.</typeparam>
        </member>
        <member name="T:V8.Net.IndexedObjectList`1">
            <summary>
            Implements a way to store managed objects which can be tracked by index for quick lookup.
            <param>Note: The indexes are similar to native pointers, and thus, an index is REQUIRED in order to retrieve or remove a reference.</param>
            </summary>
        </member>
        <member name="P:V8.Net.IndexedObjectList`1.Objects">
            <summary>
            Allows enumerating 
            </summary>
        </member>
        <member name="P:V8.Net.IndexedObjectList`1.Count">
            <summary>
            The number of managed references indexed in this instance.
            <para>Warning: this is NOT the indexed object array size.</para>
            </summary>
        </member>
        <member name="P:V8.Net.IndexedObjectList`1.ObjectIndexListCount">
            <summary>
            The current size of the list which stores the object references (this can be much larger that the actual number of objects stored).
            </summary>
        </member>
        <member name="P:V8.Net.IndexedObjectList`1.Capacity">
            <summary>
            Gets or sets the capacity of the internal reference list.  You cannot set a capacity to less than the last object in the list.
            </summary>
        </member>
        <member name="P:V8.Net.IndexedObjectList`1.UnusedIndexCount">
            <summary>
            The number of unused index positions.
            This occurs when an object is removed from within the list, and not from the end.
            <para>Note: Fragmenting does not slow down any operations.</para>
            </summary>
        </member>
        <member name="P:V8.Net.IndexedObjectList`1.Fragmentation">
            <summary>
            The percentage amount of unused index positions as compared to the total object list length.
            <para>When the last object in the internal reference list is not removed when removing other objects, the internal reference list count cannot be reduced.
            In such case, another list keeps track of the unused index positions for quick lookup.
            The fragmentation value is a simple percentage of "unused index positions" to "internal reference list count".</para>]
            <para>Note: This value is for informative purposes only.  Fragmentation does not reduce the speed additions, removals, or lookups;
            However, the internal reference list cannot reduce capacity when fragmentation exists.</para>
            </summary>
        </member>
        <member name="P:V8.Net.IndexedObjectList`1.Item(System.Int32)">
            <summary>
            Returns the object at the given object index.
            </summary>
        </member>
        <member name="M:V8.Net.IndexedObjectList`1.#ctor(System.Int32)">
            <summary>
            Create an indexed object list with the given capacity.
            <para>Warning: There are 3 lists created internally with the given capacity:  One for indexed storage, one for quick query of consecutive items, and
            another for unused index positions.  These 3 lists ensure maximum speed for most needed operations.</para>
            </summary>
            <param name="capacity">The capacity allows to pre-allocate the internal list's initial length to reduce the need to keep reallocating memory as objects are added.</param>
        </member>
        <member name="M:V8.Net.IndexedObjectList`1.Add(`0)">
            <summary>
            Add object and return the index position.
            </summary>
        </member>
        <member name="M:V8.Net.IndexedObjectList`1.Remove(System.Int32)">
            <summary>
            Removes the object at the given index and sets the entry to 'default(T)' (which is usually 0 or null).
            </summary>
        </member>
        <member name="M:V8.Net.IndexedObjectList`1.Compact">
            <summary>
            The internal lists never shrink capacity for speed reasons.
            If a large number of objects where added and later removed, call this method to shrink the memory used (if possible).
            </summary>
        </member>
        <member name="M:V8.Net.IndexedObjectList`1.Clear">
            <summary>
            Clears the internal lists and resets them to default initial capacity.
            </summary>
        </member>
        <member name="P:V8.Net.IJSProperty.Value">
            <summary>
            A JavaScript associated value.
            Call one of the "Create???()" methods to create/build a required type for the JavaScript value that represents 'Source'.
            <para>Note: Because this is a value type property, just assign a value to the property - DON'T call '{InternalHandle}.Set()', it will not work as expected.</para>
            </summary>
        </member>
        <member name="P:V8.Net.IJSProperty.Attributes">
            <summary>
            'V8PropertyAttributes' flags combined to describe the value, such as visibility, or what kind of access is allowed.
            </summary>
        </member>
        <member name="T:V8.Net.JSProperty`1">
            <summary>
            A convenient JavaScript property wrapper which also holds JavaScript property attribute flags. The generic type 'TSourceValue' is the type of value to be stored on the managed side.
            This JSProperty object also allows storing an associated V8 value handle. Having both a managed source value and a separate V8 value allows the source
            value to be represented in JavaScript as a different type. For example, a value may exist locally as a string, but in JavaScript as a number (or vice versa).
            Developers can inherit from this class if desired, or choose to go with a custom implementation using the IJSProperty interface instead.
            </summary>
            <typeparam name="TValueSource">When implementing properties for an IV8ManagedObject, this is the type that will store the property source value/details (such as 'object' - as already implemented in the derived 'JSProperty' class [the non-generic version]).</typeparam>
        </member>
        <member name="F:V8.Net.JSProperty`1.Source">
            <summary>
            This is a developer-defined source reference for the JavaScript 'Value' property if needed. It is not used by V8.Net.
            </summary>
        </member>
        <member name="P:V8.Net.JSProperty`1.V8#Net#IJSProperty#Value">
            <summary>
            A JavaScript associated value.  By default, this returns 'Handle.Empty' (which means 'Value' is 'null' internally).
            Call one of the "V8Engine.Create???()" methods to create/build a required type for the JavaScript value that represents 'Source'.
            <para>Note: Because this is a value type property, just assign a value to the property - DON'T call '{InternalHandle}.Set()', it will not work as expected.</para>
            </summary>
        </member>
        <member name="P:V8.Net.JSProperty`1.V8#Net#IJSProperty#Attributes">
            <summary>
            'V8PropertyAttributes' flags combined to describe the value, such as visibility, or what kind of access is allowed.
            </summary>
        </member>
        <member name="M:V8.Net.JSProperty`1.#ctor(V8.Net.V8PropertyAttributes)">
            <summary>
            Create a new JSProperty instance to help keep track of JavaScript object properties on managed objects.
            </summary>
        </member>
        <member name="T:V8.Net.JSProperty">
            <summary>
            A convenient 'MemberInfo' specific wrapper which holds JavaScript property value and attribute flags for managed object members.
            For custom implementations, see <see cref="T:V8.Net.JSProperty`1"/>.
            </summary>
        </member>
        <member name="F:V8.Net.JSProperty.Empty">
            <summary>
            Represents an empty JSProperty, which is simply used to return an empty 'Value' property (as 'Handle.Empty').
            <para>The purpose is to prevent having to perform null reference checks when needing to reference the 'Value' property.</para>
            </summary>
        </member>
        <member name="M:V8.Net.JSProperty.#ctor(V8.Net.V8PropertyAttributes)">
            <summary>
            Create a new JSProperty instance to help keep track of JavaScript object properties on managed objects.
            </summary>
        </member>
        <member name="T:V8.Net.JSFunction">
            <summary>
            Represents a JavaScript callback function for a managed class method.
            </summary>
            <param name="isConstructCall">True only if this function is being called to construct a new object (such as using the "new" operator within JavaScript).
            If this is true, the function is expected to create and return a new object (as the constructor for that object).</param>
            <param name="args">The arguments supplied for the JavaScript function call.</param>
        </member>
        <member name="F:V8.Net.FunctionTemplate._FunctionsByType">
            <summary>
            Set this to an object that implements a call-back to execute when the function associated with this FunctionTemplate is called within JavaScript.
            </summary>
        </member>
        <member name="P:V8.Net.FunctionTemplate.InstanceTemplate">
            <summary>
            The V8 engine automatically creates two templates with every function template: one for object creation (instances) and one for function object itself (prototype inheritance).
            This property returns the ObjectTemplate wrapper associated with the V8 native instance template for creating new objects using the function in this template as the constructor.
            </summary>
        </member>
        <member name="P:V8.Net.FunctionTemplate.PrototypeTemplate">
            <summary>
            The V8 engine automatically creates two templates with every function template: one for object creation (instances) and one for object inheritance (prototypes).
            This property returns the ObjectTemplate wrapper associated with the prototype template for the function object in this template.
            </summary>
        </member>
        <member name="P:V8.Net.FunctionTemplate.HasChildObjects">
            <summary> Returns true if this template has child objects created from it. </summary>
        </member>
        <member name="M:V8.Net.FunctionTemplate.OnInitialized">
            <summary>
            Called when the object is initialized instance is ready for use.
            </summary>
        </member>
        <member name="M:V8.Net.FunctionTemplate._CallBack(System.Int32,System.Boolean,V8.Net.HandleProxy*,V8.Net.HandleProxy**,System.Int32)">
            <summary>
            This is the main entry point from the native side for all calls to functions created from function templates.
            This method exists to give an instance based delegate reference for each function template instance.
            </summary>
            <param name="managedObjectID">The object ID of a managed object for this call.</param>
            <param name="isConstructCall">'true' if this is called because of the 'new' operator in JS.</param>
            <param name="_this">The instance context, if any.</param>
            <param name="args">Any arguments from the JS call.</param>
            <param name="argCount">Number of arguments given in the JS call.</param>
            <returns></returns>
        </member>
        <member name="M:V8.Net.FunctionTemplate.GetFunctionObject``1(V8.Net.JSFunction)">
            <summary>
            Returns the specified V8Function object type associated with this function template.
            There can only ever be one native V8 function object per native V8 function template in a single native V8 JavaScript context;
            however, V8.NET (the managed side) does allow one function type per template. In this case, a single call triggers all derived types at once.
            The first callback to return a value terminates the cycle and any following callbacks are ignored.
            <para>WARNING: The returned function object will be garbage collected if you don't store the reference anywhere. If this happens, then calling 
            the function object in JavaScript will return "undefined".</para>
            </summary>
            <typeparam name="T">A type that implements IV8Function, or derives from V8Function.</typeparam>
            <param name="callback">When a new instance of type 'T' is created, it's 'Callback' property will overwritten by this value (replacing anything that may be set when it was created).
            It is expect to provide a callback method when using the default 'V8Function' object, but if you have a custom derivation you can set this to 'null'.</param>
        </member>
        <member name="M:V8.Net.FunctionTemplate.GetFunctionObject(V8.Net.JSFunction)">
            <summary>
            Returns a JavaScript V8Function object instance associated with this function template.
            There can only ever be ONE V8 function object per V8 function template in a single V8 JavaScript context;
            however, V8.NET does allow one MANAGED function type per managed template. In this case, a single call triggers all derived types at once.
            The first callback to return a value terminates the cycle and any following callbacks are ignored.
            <para>WARNING: The returned function object will be garbage collected if you don't store the reference anywhere. If this happens, then calling 
            the function object in JavaScript will return "undefined". This is because function object callbacks are dynamic and are only valid when
            the calling object is still in use.</para>
            </summary>
            <param name="callback">When a new instance of V8Function is created, it's 'Callback' property will set to the specified value.
            If you don't provide a callback, then calling the function in JavaScript will simply do nothing and return "undefined".</param>
        </member>
        <member name="M:V8.Net.FunctionTemplate.CreateNativeInstance(V8.Net.InternalHandle[])">
            <summary>
            Calls the underlying native function to create a new native object and return its handle.
            Use this method if you only need the native object and not a managed wrapper.
            </summary>
            <param name="args">Arguments to pass to the function to construct the new native instance.</param>
            <returns>A handle to the new object.</returns>
        </member>
        <member name="M:V8.Net.FunctionTemplate.CreateInstance``1(V8.Net.InternalHandle[])">
            <summary>
            Calls the underlying native function to create and return a new instance, which will be wrapped in the specified managed object type.
            </summary>
            <typeparam name="T">A managed object type to wrap the new native object handle.</typeparam>
            <param name="args">Arguments to pass to the function to construct the new native instance.</param>
            <returns>A new instance of 'T'.</returns>
        </member>
        <member name="M:V8.Net.FunctionTemplate.CreateInstance(V8.Net.InternalHandle[])">
            <summary>
            Calls the underlying native function to create and return a new instance, which will be wrapped in a 'V8ManagedObject' instance.
            </summary>
            <param name="args">Arguments to pass to the function to construct the new native instance.</param>
            <returns>A new instance of 'V8ManagedObject'.</returns>
        </member>
        <member name="M:V8.Net.FunctionTemplate._RemoveFunctionType(System.Int32)">
            <summary>
            This is called by '{V8NativeObject}._OnNativeGCRequested()' when the managed function object is ready to be deleted.
            </summary>
        </member>
        <member name="M:V8.Net.FunctionTemplate.SetProperty(System.String,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary>
            Calls the V8 'Set()' function on the underlying native function template to set properties that will exist on all function objects created from this template.
            </summary>
        </member>
        <member name="T:V8.Net.IBasicHandle">
            <summary>
            The basic handle interface is a higher level interface that implements members that can be common to many handle types for various 3rd-party script
            implementations.  It's primary purpose is to support the DreamSpace.Net development framework, which can support various scripting engines, and is
            designed to be non-V8.NET specific.  Third-party scripts should implement this interface for their handles, or create and return value wrappers that
            implement this interface.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.Value">
            <summary>
            Returns the underlying value of this handle.
            If the handle represents an object, the the object OR a value represented by the object is returned.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.Object">
            <summary>
            Returns the underlying object associated with this handle.
            This exists because 'Value' my not return the underlying object, depending on implementation.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.HasObject">
            <summary>
            Returns true if this handle is associated with a CLR object.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsEmpty">
            <summary>
            Returns true if this handle is empty (that is, equal to 'Handle.Empty'), and false if a valid handle exists.
            <para>An empty state is when a handle is set to 'Handle.Empty' and has no valid native V8 handle assigned.
            This is similar to "undefined"; however, this property will be true if a valid native V8 handle exists that is set to "undefined".</para>
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsUndefined">
            <summary>
            Returns true if this handle is undefined or empty (empty is when this handle is an instance of 'Handle.Empty').
            <para>"Undefined" does not mean "null".  A variable (handle) can be defined and set to "null".</para>
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsNull">
            <summary>
            Returns 'true' if this handle represents a 'null' value (that is, an explicitly defined 'null' value).
            This will return 'false' if 'IsEmpty' or 'IsUndefined' is true.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsBoolean">
            <summary>
            The handle represents a Boolean value.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsInt32">
            <summary>
            The handle represents an Int32 value.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsNumber">
            <summary>
            The handle represents a number value.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsString">
            <summary>
            The handle represents a string value.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsObject">
            <summary>
            The handle represents a *script* object.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsFunction">
            <summary>
            The handle represents a function/procedure/method value.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsDate">
            <summary>
            The handle represents a date value.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsArray">
            <summary>
            The handle represents an array object.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsRegExp">
            <summary>
            The handle represents a regular expression object.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsObjectType">
            <summary>
            Returns true of the handle represents ANY *script* object type.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.IsError">
            <summary>
            Returns true of this handle represents an error.
            </summary>
        </member>
        <member name="M:V8.Net.IBasicHandle.As``1">
            <summary>
            Returns the 'Value' property type cast to the expected type.
            Warning: No conversion is made between different value types.
            </summary>
        </member>
        <member name="M:V8.Net.IBasicHandle.LastAs``1">
            Returns the 'LastValue' property type cast to the expected type.
            Warning: No conversion is made between different value types.
        </member>
        <member name="P:V8.Net.IBasicHandle.AsBoolean">
            <summary>
            Returns the underlying value converted if necessary to a Boolean type.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.AsInt32">
            <summary>
            Returns the underlying value converted if necessary to an Int32 type.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.AsDouble">
            <summary>
            Returns the underlying value converted if necessary to a double type.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.AsString">
            <summary>
            Returns the underlying value converted if necessary to a string type.
            </summary>
        </member>
        <member name="P:V8.Net.IBasicHandle.AsDate">
            <summary>
            Returns the underlying value converted if necessary to a DateTime type.
            </summary>
        </member>
        <member name="T:V8.Net.IHandle">
            <summary>
            Represents a handle type for tracking native objects.
            </summary>
        </member>
        <member name="P:V8.Net.IHandle.ID">
            <summary>
            The ID of that native side proxy handle that this managed side handle represents.
            </summary>
        </member>
        <member name="M:V8.Net.IHandle.Set(V8.Net.InternalHandle)">
            <summary>
            Disposes the current handle and sets it to another handle. Before setting, 'KeepAlive()' is called on the given
            handle so both handles can be tracked. Once this handle is set you can treat it like any other object
            reference and copy it around like a normal value (i.e. no need to keep calling this method). A rule of thumb is to 
            either set 'keepAlive' to true when creating a new handle via 'new InternalHandle(...)', or use this method to set
            the initial value.
            <para>Note 1: Under the new handle system, when 'KeepAlive()' is called (default mode for V8NativeObject handles),
            you do not need to call this method anymore. The GC will track it and dispose it when ready.</para>
            <para>Note 2: If the current handle is locked (see IsLocked) then an exception error can occur.</para>
            </summary>
        </member>
        <member name="P:V8.Net.IHandle.IsDisposed">
            <summary>
            Returns true if this handle is disposed (no longer in use).  Disposed native proxy handles are kept in a cache for performance reasons.
            </summary>
        </member>
        <member name="P:V8.Net.IHandle.IsEmpty">
            <summary>
            Returns true if this handle is empty (not associated with a native side handle).
            </summary>
        </member>
        <member name="T:V8.Net.IHandleBased">
            <summary>
            Represents a type that uses or supports a handle.
            </summary>
        </member>
        <member name="P:V8.Net.IHandleBased.Engine">
            <summary>
            Returns the engine associated with this instance.
            </summary>
        </member>
        <member name="P:V8.Net.IHandleBased.InternalHandle">
            <summary>
            Returns a handle value associated with this instance.
            </summary>
        </member>
        <member name="P:V8.Net.IHandleBased.Object">
            <summary>
            Returns the object for this instance, or 'null' if not applicable/available.
            </summary>
        </member>
        <member name="T:V8.Net.IV8Object">
            <summary>
            Represents methods that can be called on V8 objects (this includes handles).
            </summary>
        </member>
        <member name="M:V8.Net.IV8Object.SetProperty(System.String,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary>
            Calls the V8 'Set()' function on the underlying native object.
            Returns true if successful.
            </summary>
            <param name="attributes">Flags that describe the property behavior.  They must be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.IV8Object.SetProperty(System.Int32,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary>
            Calls the V8 'Set()' function on the underlying native object.
            Returns true if successful.
            </summary>
            <param name="index"> Zero-based index to set. </param>
            <param name="value"> The value to set. </param>
            <param name="attributes">
                (Optional) Flags that describe the property behavior.  They must be 'OR'd together as needed.
                <para>Warning: V8 does not support setting attributes using numerical indexes.  If you set an attribute, the given
                value is converted to a string, and a named property setter will be used instead. </para>
            </param>
        </member>
        <member name="M:V8.Net.IV8Object.SetProperty(System.String,System.Object,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Sets a property to a given object. If the object is not V8.NET related, then the system will attempt to bind the instance and all public members to
            the specified property name.
            Returns true if successful.
            </summary>
            <param name="name">The property name.</param>
            <param name="obj">Some value or object instance. 'Engine.CreateValue()' will be used to convert value types.</param>
            <param name="className">A custom in-script function name for the specified object type, or 'null' to use either the type name as is (the default) or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">For object instances, if true, then object reference members are included, otherwise only the object itself is bound and returned.
            For security reasons, public members that point to object instances will be ignored. This must be true to included those as well, effectively allowing
            in-script traversal of the object reference tree (so make sure this doesn't expose sensitive methods/properties/fields).</param>
            <param name="memberSecurity">For object instances, these are default flags that describe JavaScript properties for all object instance members that
            don't have any 'ScriptMember' attribute.  The flags should be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.IV8Object.SetProperty(System.Type,V8.Net.V8PropertyAttributes,System.String,System.Nullable{System.Boolean},System.Nullable{V8.Net.ScriptMemberSecurity})">
            <summary>
            Binds a 'V8Function' object to the specified type and associates the type name (or custom script name) with the underlying object.
            Returns true if successful.
            </summary>
            <param name="type">The type to wrap.</param>
            <param name="propertyAttributes">Flags that describe the property behavior.  They must be 'OR'd together as needed.</param>
            <param name="className">A custom in-script function name for the specified type, or 'null' to use either the type name as is (the default) or any existing 'ScriptObject' attribute name.</param>
            <param name="recursive">For object types, if true, then object reference members are included, otherwise only the object itself is bound and returned.
            For security reasons, public members that point to object instances will be ignored. This must be true to included those as well, effectively allowing
            in-script traversal of the object reference tree (so make sure this doesn't expose sensitive methods/properties/fields).</param>
            <param name="memberSecurity">For object instances, these are default flags that describe JavaScript properties for all object instance members that
            don't have any 'ScriptMember' attribute.  The flags should be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.IV8Object.GetProperty(System.String)">
            <summary>
            Calls the V8 'Get()' function on the underlying native object.
            If the property doesn't exist, the 'IsUndefined' property will be true.
            </summary>
        </member>
        <member name="M:V8.Net.IV8Object.GetProperty(System.Int32)">
            <summary>
            Calls the V8 'Get()' function on the underlying native object.
            If the property doesn't exist, the 'IsUndefined' property will be true.
            </summary>
        </member>
        <member name="M:V8.Net.IV8Object.DeleteProperty(System.String)">
            <summary>
            Calls the V8 'Delete()' function on the underlying native object.
            Returns true if the property was deleted.
            </summary>
        </member>
        <member name="M:V8.Net.IV8Object.DeleteProperty(System.Int32)">
            <summary>
            Calls the V8 'Delete()' function on the underlying native object.
            Returns true if the property was deleted.
            </summary>
        </member>
        <member name="M:V8.Net.IV8Object.SetAccessor(System.String,V8.Net.GetterAccessor,V8.Net.SetterAccessor,V8.Net.V8PropertyAttributes,V8.Net.V8AccessControl)">
            <summary>
            Calls the V8 'SetAccessor()' function on the underlying native object to create a property that is controlled by "getter" and "setter" callbacks.
            </summary>
        </member>
        <member name="M:V8.Net.IV8Object.GetPropertyNames">
            <summary>
            Returns a list of all property names for this object (including all objects in the prototype chain).
            </summary>
        </member>
        <member name="M:V8.Net.IV8Object.GetOwnPropertyNames">
            <summary>
            Returns a list of all property names for this object (excluding the prototype chain).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:V8.Net.IV8Object.GetPropertyAttributes(System.String)" -->
        <member name="M:V8.Net.IV8Object.Call(System.String,V8.Net.InternalHandle,V8.Net.InternalHandle[])">
            <summary>
            Calls an object property with a given name on a specified object as a function and returns the result.
            The '_this' property is the "this" object within the function when called.
            If the function name is null or empty, then the current object is assumed to be a function object.
            </summary>
        </member>
        <member name="M:V8.Net.IV8Object.StaticCall(System.String,V8.Net.InternalHandle[])">
            <summary>
            Calls an object property with a given name on a specified object as a function and returns the result.
            If the function name is null or empty, then the current object is assumed to be a function object.
            </summary>
        </member>
        <member name="P:V8.Net.ITemplate.Engine">
            <summary>
            The V8Engine instance associated with this template.
            </summary>
        </member>
        <member name="P:V8.Net.TemplateBase`1.Parent">
            <summary>
            Returns the parent to this template, if any.
            This is currently only set on object template instances associated with function templates (where {FunctionTemplate} is the parent).
            </summary>
        </member>
        <member name="P:V8.Net.TemplateBase`1.V8#Net#ITemplateInternal#_ReferenceCount">
            <summary>
            The number of objects that reference this object.
            This is required because of the way the GC resets all weak references to null, and finalizes in no special order.
            Dependent objects are required to update this when they are finally collected (as some may become re-registered with the finalizer).
            </summary>
        </member>
        <member name="M:V8.Net.TemplateBase`1._SetDelegate``1(``0)">
            <summary>
            Keeps callback delegates alive.
            <para>If delegates are used as callbacks (for reverse P/Invoke), then they will become GC'd if there's no managed reference keeping them alive.</para>
            </summary>
        </member>
        <member name="P:V8.Net.TemplateBase`1.HasChildObjects">
            <summary> Returns true if this template has child objects created from it. </summary>
        </member>
        <member name="M:V8.Net.ObjectTemplate.OnInitialized">
            <summary>
            Called when the object is initialized instance is ready for use.
            </summary>
        </member>
        <member name="P:V8.Net.ObjectTemplate.NamedPropertyInterceptorsRegistered">
            <summary>
            Returns true if this function template has any name-based interceptors (callbacks) registered.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:V8.Net.ObjectTemplate.IndexedPropertyInterceptorsRegistered" -->
        <member name="M:V8.Net.ObjectTemplate.RegisterNamedPropertyInterceptors">
            <summary>
            Registers handlers that intercept access to properties on ALL objects created by this template.  The native V8 engine only supports this on 'ObjectTemplate's.
            </summary>
        </member>
        <member name="M:V8.Net.ObjectTemplate.RegisterIndexedPropertyInterceptors">
            <summary>
            Registers handlers that intercept access to properties on ALL objects created by this template.  The native V8 engine only supports this on 'ObjectTemplate's.
            </summary>
        </member>
        <member name="M:V8.Net.ObjectTemplate.UnregisterPropertyInterceptors">
            <summary>
            Unregisters handlers that intercept access to properties on ALL objects created by this template.  See <see cref="M:V8.Net.ObjectTemplate.RegisterNamedPropertyInterceptors"/> and <see cref="M:V8.Net.ObjectTemplate.RegisterIndexedPropertyInterceptors"/>.
            </summary>
        </member>
        <member name="M:V8.Net.ObjectTemplate.SetCallAsFunctionHandler(V8.Net.JSFunction)">
            <summary>
                Registers an invoke handler on the underlying native ObjectTemplate instance, which allows objects to be called like
                a function.
                <para>A proxy delegate is used and stored locally to prevent it from being reclaimed by the
                GC. If you call this method again, the old proxy delegate will be replaced with a new one and registered again on
                the native side. </para>
            </summary>
            <param name="callback"> A callback that gets invoked when the object is used like a function. </param>
        </member>
        <member name="M:V8.Net.ObjectTemplate.CreateObject``1(System.Boolean)">
            <summary>
            Creates an object of the specified type and returns it.  A V8 object is also created and associated with it.
            <para>Performance note: Creating 'V8NativeObject' type objects are allowed, but an object template is not needed for those.  If you create a
            'V8NativeObject' object from a template, it simply wraps the native object create by the template, and property interceptors (call-backs) are still
            triggered.  While native objects are faster than managed ones, creating 'V8NativeObject' objects using 'V8Engine.CreateObject()' does not use
            interceptors and is many times faster than template objects.  If it is desired to create 'V8NativeObject' objects from templates, consider calling
            '<seealso cref="M:V8.Net.ObjectTemplate.UnregisterPropertyInterceptors"/>' on the object template to make them the same speed as if 'V8Engine.CreateObject()' was used.</para>
            </summary>
            <typeparam name="T">The type of managed object to create, which must implement 'IV8NativeObject',</typeparam>
            <param name="initialize">If true (default) then then 'IV8NativeObject.Initialize()' is called on the created object before returning.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:V8.Net.ObjectTemplate.CreateObject(System.Boolean)" -->
        <member name="M:V8.Net.ObjectTemplate.SetProperty(System.String,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary>
            Calls the V8 'Set()' function on the underlying native object template to set properties that will exist on all objects created from this template.
            </summary>
        </member>
        <member name="P:V8.Net.ObjectTemplate.Getter">
            <summary>
                This is updated to hold a reference to the property value getter callback when
                <see cref="M:V8.Net.ObjectTemplate.SetAccessor(System.String,V8.Net.GetterAccessor,V8.Net.SetterAccessor,V8.Net.V8PropertyAttributes,V8.Net.V8AccessControl)"/> is called.
                Without a rooted reference the delegate will get garbage collected causing callbacks from the native side will fail.
            </summary>
            <value> The getter. </value>
        </member>
        <member name="P:V8.Net.ObjectTemplate.Setter">
            <summary>
                This is updated to hold a reference to the property value setter callback when
                <see cref="M:V8.Net.ObjectTemplate.SetAccessor(System.String,V8.Net.GetterAccessor,V8.Net.SetterAccessor,V8.Net.V8PropertyAttributes,V8.Net.V8AccessControl)"/> is called.
                Without a rooted reference the delegate will get garbage collected causing callbacks from the native side will fail.
            </summary>
            <value> The getter. </value>
        </member>
        <member name="M:V8.Net.ObjectTemplate.SetAccessor(System.String,V8.Net.GetterAccessor,V8.Net.SetterAccessor,V8.Net.V8PropertyAttributes,V8.Net.V8AccessControl)">
            <summary>
            Calls the V8 'SetAccessor()' function on the underlying native 'v8::ObjectTenplate' instance to create a property that is controlled by "getter" and "setter" callbacks.
            <para>Note: This is template related, which means all objects created from this template will be affected by these special properties.</para>
            </summary>
        </member>
        <member name="T:V8.Net.IV8ManagedObject">
            <summary>
            The 'V8ManagedObject' class implements 'DynamicObject' for you, but if dynamic objects are not required, feel free to implement
            the 'IV8ManagedObject' interface for your own classes instead.
            </summary>
        </member>
        <member name="P:V8.Net.IV8ManagedObject.NamedProperties">
            <summary>
            Holds a Key->Value reference to all property names and values for the JavaScript object that this managed object represents.
            Accessing the 'Properties' property without setting it first creates a new dictionary object by default.
            </summary>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.NamedPropertyGetter(System.String@)">
            <summary>
            Intercepts JavaScript access for properties on the associated JavaScript object for retrieving a value.
            <para>To allow the V8 engine to perform the default get action, return "Handle.Empty".</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.NamedPropertySetter(System.String@,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary>
            Intercepts JavaScript access for properties on the associated JavaScript object for setting values.
            <para>To allow the V8 engine to perform the default set action, return "Handle.Empty".</para>
            </summary>
            <param name="attributes">Flags that describe the property behavior.  They must be 'OR'd together as needed.</param>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.NamedPropertyQuery(System.String@)">
            <summary>
            Let's the V8 engine know the attributes for the specified property.
            <para>To allow the V8 engine to perform the default get action, return "null".</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.NamedPropertyDeleter(System.String@)">
            <summary>
            Intercepts JavaScript request to delete a property.
            <para>To allow the V8 engine to perform the default get action, return "null".</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.NamedPropertyEnumerator">
            <summary>
            Returns the results of enumeration (such as when "for..in" is used).
            <para>To allow the V8 engine to perform the default set action, return "Handle.Empty".</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.IndexedPropertyGetter(System.Int32)">
            <summary>
            Intercepts JavaScript access for properties on the associated JavaScript object for retrieving a value.
            <para>To allow the V8 engine to perform the default get action, return "Handle.Empty".</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.IndexedPropertySetter(System.Int32,V8.Net.InternalHandle,V8.Net.V8PropertyAttributes)">
            <summary>
                Intercepts JavaScript access for properties on the associated JavaScript object for setting values.
                <para>To allow the V8 engine to perform the default set action, return "Handle.Empty".</para>
            </summary>
            <param name="index"> Zero-based index to set. </param>
            <param name="value"> The value to set. </param>
            <param name="attributes">
                (Optional) Flags that describe the property behavior.  They must be 'OR'd together as needed.
                <para>Warning: V8 does not support setting attributes using numerical indexes.  If you set an attribute, the given
                value is converted to a string, and a named property setter will be used instead. </para>
            </param>
            <returns> An InternalHandle. </returns>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.IndexedPropertyQuery(System.Int32)">
            <summary>
            Let's the V8 engine know the attributes for the specified property.
            <para>To allow the V8 engine to perform the default get action, return "null".</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.IndexedPropertyDeleter(System.Int32)">
            <summary>
            Intercepts JavaScript request to delete a property.
            <para>To allow the V8 engine to perform the default get action, return "null".</para>
            </summary>
        </member>
        <member name="M:V8.Net.IV8ManagedObject.IndexedPropertyEnumerator">
            <summary>
            Returns the results of enumeration (such as when "for..in" is used).
            <para>To allow the V8 engine to perform the default set action, return "Handle.Empty".</para>
            </summary>
        </member>
        <member name="T:V8.Net.V8ManagedObject">
            <summary>
            Represents a C# (managed) JavaScript object.  Properties are set on the object within the class itself, and not within V8.
            This is done by using V8 object interceptors (callbacks).  By default, this object is used for the global environment.
            <para>The inherited 'V8NativeObject' base class implements 'DynamicObject' for you, but if dynamic objects are not required, 
            feel free to implement the 'IV8ManagedObject' interface for your own classes instead; however, you also will have to call the
            V8NetProxy static methods yourself if you need functionality supplied by V8NativeObject.</para>
            <para>Note: It's faster to work with the properties on the managed side using this object, but if a lot of properties won't be changing,
            it may be faster to access properties within V8 itself.  To do so, simply create a basic V8NativeObject using 'V8Engine.CreateObject()'
            instead.</para>
            </summary>
        </member>
        <member name="P:V8.Net.V8ManagedObject.Handle">
            <summary>
            A reference to the managed object handle that wraps the native V8 handle for this managed object (this simply returns 'base.Handle'). 
            You should never change handles on managed objects because they are usually associated with object interceptors,
            and changing the handle will break the call-back system.
            </summary>
        </member>
        <member name="P:V8.Net.V8ManagedObject.ObjectTemplate">
            <summary>
            A reference to the ObjectTemplate instance that owns this object.
            </summary>
        </member>
        <member name="P:V8.Net.V8ManagedObject.NamedProperties">
            <summary>
            Holds a Key->Value reference to all property names and values for the JavaScript object that this managed object represents.
            Accessing the 'Properties' property without setting it first creates a new dictionary object by default.
            </summary>
        </member>
        <member name="P:V8.Net.V8ManagedObject.IndexedProperties">
            <summary>
            Holds a Key->Value reference to all numerical indexed values for the JavaScript object that this managed object represents.
            Accessing the 'Properties' property without setting it first creates a new dictionary object by default.
            </summary>
        </member>
        <member name="T:V8.Net.V8ManagedObject`1">
            <summary>
            This generic version of 'V8ManagedObject' allows injecting your own class by implementing the 'IV8ManagedObject' interface.
            </summary>
            <typeparam name="T">Your own class, which implements the 'IV8ManagedObject' interface.  Don't use the generic version if you are able to inherit from 'V8ManagedObject' instead.</typeparam>
        </member>
    </members>
</doc>
